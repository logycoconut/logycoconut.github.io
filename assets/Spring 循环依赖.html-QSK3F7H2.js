import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as t,o as n}from"./app-BsnKshpw.js";const c={};function l(a,e){return n(),i("div",null,e[0]||(e[0]=[t('<blockquote><p>【第二次讲 Spring 循环依赖，时长 16 分钟，我保证每一秒都是精华】 <a href="https://www.bilibili.com/video/BV1ET4y1N7Sp" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1ET4y1N7Sp</a></p><p>大叔讲的非常清楚 !！<br> 听不懂的建议反复观看</p></blockquote><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><ul><li><p>在哪里获取 <code>Bean</code>？<code>Bean</code> 工厂 （<code>ObjectFactory</code>）</p></li><li><p><code>Bean</code> 工厂的 <code>Bean</code> 哪里来？从 <code>Bean</code> 仓库（单例池 <code>SingletonBeanRegistry</code>）中获取</p></li></ul><h3 id="一个简单-bean-的创建和管理" tabindex="-1"><a class="header-anchor" href="#一个简单-bean-的创建和管理"><span>一个简单 Bean 的创建和管理</span></a></h3><ul><li>获取 Bean，查看单例池中是否存在 A</li><li>单例池中存在，直接返回 A，不存在则实例化一个 A</li><li>为 A 对象填充属性（在例子中为 id 属性）</li><li>完成初始化，并放入单例池中</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183133.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="稍复杂-bean-的创建" tabindex="-1"><a class="header-anchor" href="#稍复杂-bean-的创建"><span>稍复杂 Bean 的创建</span></a></h3><ul><li>获取 Bean，查看单例池中是否存在 A</li><li>单例池中存在，直接返回 A，不存在则实例化一个 A</li><li>为 A 对象填充属性（在例子中为 id 属性）</li><li>A 中有 B 对象，查看单例池中是否存在 B</li><li>存在则直接返回 B，不存在则实例化一个 B</li><li>为 B 对象填充属性（在例子中为 name 属性）</li><li>完成 B 的初始化，并放入单例池中</li><li>完成 A 的初始化，并放入单例池中</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183201.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="循环依赖" tabindex="-1"><a class="header-anchor" href="#循环依赖"><span>循环依赖</span></a></h3><blockquote><p>先前两个例子只需要一个单例池就可以完成 Bean 的创建与管理，下面来看一个稍微复杂的例子</p></blockquote><p><code>Object A</code> 与 <code>Object B</code> 存在相互引用的情况<br> 如果还是按照上述步骤执行的话，那将会陷入无限实例化 <code>Object</code> 的循环中（因为单例池中始终没有所需要的 <code>Bean</code>）</p><p><em><strong>此时，我们增加一个半成品池子（二级缓存）</strong></em></p><ul><li>获取 Bean，查看单例池中是否存在 A</li><li>单例池中存在，直接返回 A，不存在则实例化一个 A，将 A 放入半成品池子中</li><li>为 A 对象填充属性（在例子中为 id 属性）</li><li>A 中有 B 对象，查看单例池中是否存在 B</li><li>存在则直接返回 B，不存在则实例化一个 B，将 B 放入半成品池子中</li><li>为 B 对象填充属性（在例子中为 name 属性）</li><li>为 B 对象填充属性 A，B 先在单例池中查找 A，ok 没有找到，继续在半成品池子中查找 A，此时可以查找到，完成填充</li><li>完成 B 的初始化，并放入单例池中，并移除半成品池中的 B</li><li>完成 A 的初始化，并放入单例池中，并移除半成品池中的 A</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183255.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="aop-对象处理" tabindex="-1"><a class="header-anchor" href="#aop-对象处理"><span>AOP 对象处理</span></a></h3><blockquote><p>按照上述的理论，我们已经成功地解决了 <code>Bean</code> 的循环依赖<br> 但是为什么 <code>Spring</code> 中使用了三级缓存来解决循环依赖呢</p><p>对咯，还存在着 <code>AOP</code> 代理的情况～</p></blockquote><p>在存在代理的情况下，<code>Object A </code> 中的属性 b 不应该真的是 <code>Object B</code>，而应该是 <code>Proxy B</code></p><p>而二级缓存解决不了这个问题，所以引入了三级缓存</p><ul><li>*AOP 代理发生在 Bean 的初始化中，在 Bean 的后置处理中生成一个代理对象<br> （ BeanPostProcessor 的 postProcessAfterInitialization，调用 createProxy ）</li><li><em>AOP 处理器中还存在着方法 getEarlyBeanReference，在提前用到 A 对象时调用方法获取代理对象（不提前引用的情况下不会调用）</em></li></ul><p><strong>存在 AOP 代理的情况下，单例池中存放的是代理对象，而不是 Bean 本身!!!</strong></p><p><strong>具体步骤</strong></p><ul><li>获取 Bean，查看单例池中是否存在 A</li><li>单例池中存在，直接返回 A，不存在则实例化一个 A，并创建一个 <code>Factory A</code> 放入工厂池中（<code>Factory A</code> 的作用就是用来调用 <code>getEarlyBeanReference</code> 方法获取代理对象）</li><li>为 A 对象填充属性（在例子中为 id 属性）</li><li>A 中有 B 对象，查看单例池中是否存在 B</li><li>存在则直接返回 B，不存在则实例化一个 B，并创建一个 <code>Factory B</code> 放入工厂池中</li><li>为 B 对象填充属性（在例子中为 name 属性）</li><li>为 B 对象填充属性 A，B 先在单例池中查找 A，ok 没有找到，继续在半成品池子中查找 A，也没有，最终在工厂池中发现了 <code>Factory A</code></li><li>此时满足了 <code>Proxy A</code> 提前引用的条件，调用 <code>getEarlyBeanReference</code> 方法获取代理对象 <code>Proxy A</code> 并放入半成品池子中，并且移除工厂池中的 <code>Factory A</code></li><li>完成 B 的初始化，并放入单例池中，并移除工厂池中的 <code>Factory B</code></li><li>完成 A 的初始化，并放入单例池中，并移除半成品池中的 <code>Proxy A</code></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183319.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure>',24)]))}const d=o(c,[["render",l],["__file","Spring 循环依赖.html.vue"]]),g=JSON.parse(`{"path":"/project/Interview/Spring/Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html","title":"Spring 循环依赖","lang":"zh-CN","frontmatter":{"title":"Spring 循环依赖","tag":["Spring"],"description":"【第二次讲 Spring 循环依赖，时长 16 分钟，我保证每一秒都是精华】 https://www.bilibili.com/video/BV1ET4y1N7Sp 大叔讲的非常清楚 !！ 听不懂的建议反复观看 基本概念 在哪里获取 Bean？Bean 工厂 （ObjectFactory） Bean 工厂的 Bean 哪里来？从 Bean 仓库（单例池...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/project/Interview/Spring/Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"Spring 循环依赖"}],["meta",{"property":"og:description","content":"【第二次讲 Spring 循环依赖，时长 16 分钟，我保证每一秒都是精华】 https://www.bilibili.com/video/BV1ET4y1N7Sp 大叔讲的非常清楚 !！ 听不懂的建议反复观看 基本概念 在哪里获取 Bean？Bean 工厂 （ObjectFactory） Bean 工厂的 Bean 哪里来？从 Bean 仓库（单例池..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183133.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"Spring"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring 循环依赖\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183133.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183201.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183255.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231219183319.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":3,"title":"一个简单 Bean 的创建和管理","slug":"一个简单-bean-的创建和管理","link":"#一个简单-bean-的创建和管理","children":[]},{"level":3,"title":"稍复杂 Bean 的创建","slug":"稍复杂-bean-的创建","link":"#稍复杂-bean-的创建","children":[]},{"level":3,"title":"循环依赖","slug":"循环依赖","link":"#循环依赖","children":[]},{"level":3,"title":"AOP 对象处理","slug":"aop-对象处理","link":"#aop-对象处理","children":[]}],"git":{"createdTime":1703001114000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":2,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":3.88,"words":1165},"filePathRelative":"project/Interview/Spring/Spring 循环依赖.md","localizedDate":"2023年12月19日","autoDesc":true}`);export{d as comp,g as data};
