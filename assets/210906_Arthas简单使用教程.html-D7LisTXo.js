import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as e,o as l}from"./app-B0PTpf3F.js";const t={};function n(r,s){return l(),a("div",null,s[0]||(s[0]=[e(`<blockquote><p>Java 应用诊断利器</p></blockquote><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h2><p>我们都知道， JVM 提供了 <strong>远程调试（Remote Debug）</strong> 的功能， IDEA 也很好地支持了这一特性</p><p>但是，在中小型公司中，测试环境往往只有一台机器（或容器）</p><p>那么，在多个需求并行开发测试的时候，功能将会合并到同一测试分支，然后进行应用部署</p><p>这时候，如果再使用远程 Debug 的方式来排查错误，会导致整个测试环境的线程都挂起，影响别人的测试</p><p>所以我们可以通过 <s>打 log 日志+ 重新部署的方式排查问题</s></p><p>或者，选择更优雅的 Debug 工具，<strong>Arthas</strong></p><h2 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令"><span>常用命令</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Arthas 通过神奇的字节码插装技术，在不修改应用代码的情况下，对业务问题进行诊断</span></span>
<span class="line"><span></span></span>
<span class="line"><span>同时提供相当完善的文档以及新手教程</span></span>
<span class="line"><span></span></span>
<span class="line"><span>这里仅仅展示我经常用的一些命令</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="watch-观察函数" tabindex="-1"><a class="header-anchor" href="#watch-观察函数"><span><code>watch</code> 观察函数</span></a></h3><p>举个例子</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 观察 UserController 的所有函数, 返回值为 {入参、抛出异常}, 当第一个入参为0时打印, 默认展开2层</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">watch</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> com.example.demo.arthas.user.UserController</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> *</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;{params, throwExp}&#39;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;params[0]==0&#39;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -x</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1.</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 第一个参数是类名，支持通配</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2.</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 第二个参数是函数名，支持通配</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3.</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 第三个参数是返回值表达式</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">4.</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 第四个参数是条件表达式</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>返回值表达式 （ <code>ognl</code> 表达式）</p><p>具体含义 <a href="https://arthas.aliyun.com/doc/advice-class.html" target="_blank" rel="noopener noreferrer"></a><a href="https://arthas.aliyun.com/doc/advice-class.html" target="_blank" rel="noopener noreferrer">https://arthas.aliyun.com/doc/advice-class.html</a></p><ul><li>loader</li><li>clazz</li><li>method</li><li>target</li><li>params</li><li>returnObj</li><li>throwExp</li><li>isBefore</li><li>isThrow</li><li>isReturn</li></ul></li><li><p>常用参数</p></li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-x</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 表示输出结果的属性遍历深度，</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 默认为1，最大为4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="tt-时空隧道" tabindex="-1"><a class="header-anchor" href="#tt-时空隧道"><span><code>tt</code> 时空隧道</span></a></h3><p><code>tt</code> 命令可以理解为 <code>watch</code> 命令的增强，它可以将一组方法的调用都记录下来，通过索引查看当时的调用情况</p><ul><li><p>查看调用信息 <code>tt -id INDEX</code></p></li><li><p>重做一次调用 <code>tt -i INDEX -p</code></p></li></ul><h3 id="cls-命令行清空" tabindex="-1"><a class="header-anchor" href="#cls-命令行清空"><span><code>cls</code> 命令行清空</span></a></h3><h3 id="jad-反编译代码" tabindex="-1"><a class="header-anchor" href="#jad-反编译代码"><span><code>jad</code> 反编译代码</span></a></h3><p>可以查看运行的代码是否是最新的代码</p><ul><li><p><code>jad --source-only {package}.{ClassName}</code> 只打印出反编译后的源代码</p></li><li><p><code>jad {package}.{ClassName}</code> 打印出反编译后的源代码以及ClassLoader、Location</p></li></ul><h3 id="热部署代码" tabindex="-1"><a class="header-anchor" href="#热部署代码"><span>热部署代码</span></a></h3><p>适用于一些简单的代码改动，无需重新提交代码并发布</p><ol><li><p>反编译代码并输出到tmp目录</p><p><code>jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</code></p></li><li><p>通过 vim 修改 <code>/tmp/UserController.java</code> 文件</p></li><li><p>查询 <code>UserController</code> 的 <code>ClassLoader</code></p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> *</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">UserController</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> classLoaderHash</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> classLoaderHash</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">   1be6f5c3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>由此可知 <code>classLoaderHash</code> 为 1be6f5c3</p></li><li><p>使用mc(Memory Compiler)命令来编译，并且通过-c或者--classLoaderClass参数指定ClassLoader</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 指定 classLoaderClass</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --classLoaderClass</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> org.springframework.boot.loader.LaunchedURLClassLoader</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /tmp/UserController.java</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /tmp</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 指定 classLoaderHash</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 1be6f5c3</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /tmp/UserController.java</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /tmp</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># -d 指定编译后的Class文件路径（Class存在全路径包名下）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>重新加载编译好的Class文件</p><p><code>redefine /tmp/com/example/demo/arthas/user/UserController.class</code></p></li></ol><h2 id="idea-插件" tabindex="-1"><a class="header-anchor" href="#idea-插件"><span>IDEA 插件</span></a></h2><p>arthas-idea 汪小哥</p><p>生成arthas命令的神器</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://arthas.aliyun.com/doc/quick-start.html" target="_blank" rel="noopener noreferrer">Arthas 官方文档</a></p><p>​​<!-- +++++++++ 下面是引用式链接 +++++++++ --></p>`,31)]))}const p=i(t,[["render",n],["__file","210906_Arthas简单使用教程.html.vue"]]),o=JSON.parse(`{"path":"/resource/code/09_tools/210906_Arthas%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html","title":"Arthas简单使用教程","lang":"zh-CN","frontmatter":{"title":"Arthas简单使用教程","date":"2021-09-06T00:00:00.000Z","tag":["Arthas"],"description":"Java 应用诊断利器 使用场景 我们都知道， JVM 提供了 远程调试（Remote Debug） 的功能， IDEA 也很好地支持了这一特性 但是，在中小型公司中，测试环境往往只有一台机器（或容器） 那么，在多个需求并行开发测试的时候，功能将会合并到同一测试分支，然后进行应用部署 这时候，如果再使用远程 Debug 的方式来排查错误，会导致整个测试...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/resource/code/09_tools/210906_Arthas%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"Arthas简单使用教程"}],["meta",{"property":"og:description","content":"Java 应用诊断利器 使用场景 我们都知道， JVM 提供了 远程调试（Remote Debug） 的功能， IDEA 也很好地支持了这一特性 但是，在中小型公司中，测试环境往往只有一台机器（或容器） 那么，在多个需求并行开发测试的时候，功能将会合并到同一测试分支，然后进行应用部署 这时候，如果再使用远程 Debug 的方式来排查错误，会导致整个测试..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"Arthas"}],["meta",{"property":"article:published_time","content":"2021-09-06T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Arthas简单使用教程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-09-06T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":2,"title":"常用命令","slug":"常用命令","link":"#常用命令","children":[{"level":3,"title":"watch 观察函数","slug":"watch-观察函数","link":"#watch-观察函数","children":[]},{"level":3,"title":"tt 时空隧道","slug":"tt-时空隧道","link":"#tt-时空隧道","children":[]},{"level":3,"title":"cls 命令行清空","slug":"cls-命令行清空","link":"#cls-命令行清空","children":[]},{"level":3,"title":"jad 反编译代码","slug":"jad-反编译代码","link":"#jad-反编译代码","children":[]},{"level":3,"title":"热部署代码","slug":"热部署代码","link":"#热部署代码","children":[]}]},{"level":2,"title":"IDEA 插件","slug":"idea-插件","link":"#idea-插件","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1676127577000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":7,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":2.51,"words":753},"filePathRelative":"resource/code/09_tools/210906_Arthas简单使用教程.md","localizedDate":"2021年9月6日","autoDesc":true}`);export{p as comp,o as data};
