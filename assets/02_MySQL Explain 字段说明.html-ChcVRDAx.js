import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as a,o as t}from"./app-DfvBXUGl.js";const l={};function s(r,e){return t(),i("div",null,e[0]||(e[0]=[a('<h2 id="explain-字段中-type-字段效率对比" tabindex="-1"><a class="header-anchor" href="#explain-字段中-type-字段效率对比"><span>Explain 字段中 type 字段效率对比</span></a></h2><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/code/mysql/20230724212815.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="const" tabindex="-1"><a class="header-anchor" href="#const"><span>Const</span></a></h3><p>主键或 UNIQUE 唯一索引，最多只会返回一条</p><h3 id="system" tabindex="-1"><a class="header-anchor" href="#system"><span>System</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/code/mysql/explain.png" alt="" loading="lazy"><br> 在 const 的基础上，如果表里只有一条数据，那就是 system</p><p>属于 const 的一种特殊情况</p><p>不会出现在 innoDB 中，在 MyISAM 中会出现</p><h3 id="eq-ref" tabindex="-1"><a class="header-anchor" href="#eq-ref"><span>Eq_ref</span></a></h3><p>通常发生在联表查询中，关联的条件为某一张表的主键或 UNIQUE 唯一非空索引</p><p>效率仅次于 system 和 const</p><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>Ref</span></a></h3><p>满足索引的最左原则，同事并不走主键或者 UNIQUE</p><p>对于非聚簇索引，通常为 ref</p><h3 id="ref-or-null" tabindex="-1"><a class="header-anchor" href="#ref-or-null"><span>Ref_or_null</span></a></h3><p>在 ref 的基础上增加 null 值的查询</p><p>由于查询 null 值需要扫描整个索引数中的行信息</p><h3 id="index-merge" tabindex="-1"><a class="header-anchor" href="#index-merge"><span>Index_merge</span></a></h3><p>对于多个索引分别进行条件扫描，然后对结果进行并集、交集、或两者的组合</p><h3 id="unique-subquery-和-index-subquery" tabindex="-1"><a class="header-anchor" href="#unique-subquery-和-index-subquery"><span>Unique_subquery 和 index_subquery</span></a></h3><p>在 MySQL 的 Service 服务层会对 SQL 进行优化，所以在存储引擎层不会在出现了</p><p>在这之后的 type 尽量不要出现，效率不高</p><h3 id="range" tabindex="-1"><a class="header-anchor" href="#range"><span>Range</span></a></h3><p>范围查询</p><h3 id="index-和-all" tabindex="-1"><a class="header-anchor" href="#index-和-all"><span>Index 和 all</span></a></h3><p>都是全表扫描，区别在于 index 值需要查询索引数就能拿到结果 all 还需要遍历所有行</p><h2 id="explain-字段中-extra" tabindex="-1"><a class="header-anchor" href="#explain-字段中-extra"><span>Explain 字段中 Extra</span></a></h2><p>介绍几种常用的</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/code/mysql/20230724212858.png" alt="Untitled 2.png" tabindex="0" loading="lazy"><figcaption>Untitled 2.png</figcaption></figure><h3 id="using-index" tabindex="-1"><a class="header-anchor" href="#using-index"><span>Using index</span></a></h3><p>想查找的数据都在索引树中，不需要回表再去查询聚簇索引</p><p>这样就可以减少不必要的查询，从而提升查询效率</p><h3 id="using-index-condition" tabindex="-1"><a class="header-anchor" href="#using-index-condition"><span>Using index condition</span></a></h3><p>索引下推 ICP Index Condition Pushdown</p><p>主要用在联合索引中</p><p>如果搜索时需要大量回表，在回表之前，会先把处理过滤逻辑 “下推” 到存储引擎中进行，过滤整理后才发到 Server 层进行处理</p><p>减少了发给 Server 层的数据量和次数，提升效率</p><h3 id="using-where" tabindex="-1"><a class="header-anchor" href="#using-where"><span>Using where</span></a></h3><p>和 ICP 相对所有过滤动作都由 Server 层处理，效率比较低</p><p>查询的列没有被索引覆盖</p><h3 id="using-mrr" tabindex="-1"><a class="header-anchor" href="#using-mrr"><span>Using MRR</span></a></h3><p>Multi-Range Read</p><p>对二级索引查询时，会先对二级索引的查询结果缓存并进行排序，然后统一去聚簇索引中回表查询</p><p>这样就可以把随机 IO 优化成顺序 IO，提升效率</p><p>默认关闭，需要手动开启 mrr_cost_based</p><h3 id="using-join-buffer-block-nested-loop-bnl" tabindex="-1"><a class="header-anchor" href="#using-join-buffer-block-nested-loop-bnl"><span>Using join buffer (Block Nested Loop BNL)</span></a></h3><p>主要发生在 A B 两表关联查询，A 的关联列上有索引而 B 的没有，就会发生 BNL 优化</p><p>步骤：</p><ol><li>从 A 表中取 10 条数据放在 Join Buffer 内存空间中</li><li>全表扫描 B 表和 Join Buffer 中这 10行关联</li><li>循环这一步，直到 A 表所有数据关联完</li></ol><p>虽说减少了 B 表的扫描次数，但还是很慢</p><h3 id="using-join-buffer-batched-key-access-bka" tabindex="-1"><a class="header-anchor" href="#using-join-buffer-batched-key-access-bka"><span>Using join buffer (Batched Key Access BKA)</span></a></h3><p>在 BNL 的基础上，如果 B 表有索引，则会配合 MRR 将 JoinBuffer 中的行进行排序后去 B 表对应索引中查，无需全表扫描</p><p>默认关闭</p><h3 id="using-union-indexs" tabindex="-1"><a class="header-anchor" href="#using-union-indexs"><span>Using union（indexs）</span></a></h3><p>多个查询条件都是索引，就会对索引进行合并</p><h3 id="using-temporary" tabindex="-1"><a class="header-anchor" href="#using-temporary"><span>Using temporary</span></a></h3><p>查询过程中用到了临时表</p><p>比如 group by、dinstinct、union</p><h3 id="using-filesort" tabindex="-1"><a class="header-anchor" href="#using-filesort"><span>Using filesort</span></a></h3><p>通常出现在 order by 中</p><p>可以通过优化避免</p><p>比如条件和排序两个字端组成联合索引，定位到条件后，排序字端本身就是有序的，就不需要额外排序了</p>',62)]))}const c=n(l,[["render",s],["__file","02_MySQL Explain 字段说明.html.vue"]]),d=JSON.parse(`{"path":"/resource/code/03_database/01_mysql/02_MySQL%20Explain%20%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E.html","title":"MySQL Explain 字段说明","lang":"zh-CN","frontmatter":{"title":"MySQL Explain 字段说明","tag":["MySQL"],"description":"Explain 字段中 type 字段效率对比 Const 主键或 UNIQUE 唯一索引，最多只会返回一条 System 在 const 的基础上，如果表里只有一条数据，那就是 system 属于 const 的一种特殊情况 不会出现在 innoDB 中，在 MyISAM 中会出现 Eq_ref 通常发生在联表查询中，关联的条件为某一张表的主键或 U...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/resource/code/03_database/01_mysql/02_MySQL%20Explain%20%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"MySQL Explain 字段说明"}],["meta",{"property":"og:description","content":"Explain 字段中 type 字段效率对比 Const 主键或 UNIQUE 唯一索引，最多只会返回一条 System 在 const 的基础上，如果表里只有一条数据，那就是 system 属于 const 的一种特殊情况 不会出现在 innoDB 中，在 MyISAM 中会出现 Eq_ref 通常发生在联表查询中，关联的条件为某一张表的主键或 U..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/code/mysql/20230724212815.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL Explain 字段说明\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/code/mysql/20230724212815.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/code/mysql/explain.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/code/mysql/20230724212858.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"Explain 字段中 type 字段效率对比","slug":"explain-字段中-type-字段效率对比","link":"#explain-字段中-type-字段效率对比","children":[{"level":3,"title":"Const","slug":"const","link":"#const","children":[]},{"level":3,"title":"System","slug":"system","link":"#system","children":[]},{"level":3,"title":"Eq_ref","slug":"eq-ref","link":"#eq-ref","children":[]},{"level":3,"title":"Ref","slug":"ref","link":"#ref","children":[]},{"level":3,"title":"Ref_or_null","slug":"ref-or-null","link":"#ref-or-null","children":[]},{"level":3,"title":"Index_merge","slug":"index-merge","link":"#index-merge","children":[]},{"level":3,"title":"Unique_subquery 和 index_subquery","slug":"unique-subquery-和-index-subquery","link":"#unique-subquery-和-index-subquery","children":[]},{"level":3,"title":"Range","slug":"range","link":"#range","children":[]},{"level":3,"title":"Index 和 all","slug":"index-和-all","link":"#index-和-all","children":[]}]},{"level":2,"title":"Explain 字段中 Extra","slug":"explain-字段中-extra","link":"#explain-字段中-extra","children":[{"level":3,"title":"Using index","slug":"using-index","link":"#using-index","children":[]},{"level":3,"title":"Using index condition","slug":"using-index-condition","link":"#using-index-condition","children":[]},{"level":3,"title":"Using where","slug":"using-where","link":"#using-where","children":[]},{"level":3,"title":"Using MRR","slug":"using-mrr","link":"#using-mrr","children":[]},{"level":3,"title":"Using join buffer (Block Nested Loop BNL)","slug":"using-join-buffer-block-nested-loop-bnl","link":"#using-join-buffer-block-nested-loop-bnl","children":[]},{"level":3,"title":"Using join buffer (Batched Key Access BKA)","slug":"using-join-buffer-batched-key-access-bka","link":"#using-join-buffer-batched-key-access-bka","children":[]},{"level":3,"title":"Using union（indexs）","slug":"using-union-indexs","link":"#using-union-indexs","children":[]},{"level":3,"title":"Using temporary","slug":"using-temporary","link":"#using-temporary","children":[]},{"level":3,"title":"Using filesort","slug":"using-filesort","link":"#using-filesort","children":[]}]}],"git":{"createdTime":1690289097000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":5,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":2.81,"words":843},"filePathRelative":"resource/code/03_database/01_mysql/02_MySQL Explain 字段说明.md","localizedDate":"2023年7月25日","autoDesc":true}`);export{c as comp,d as data};
