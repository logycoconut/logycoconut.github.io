import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as i,o as p}from"./app-CAtmO8tN.js";const c={};function a(n,e){return p(),o("div",null,[...e[0]||(e[0]=[i('<p>目前，Redis 的持久化主要有两大机制，即 AOF 日志（Append Only File） 和 RDB 快照</p><h3 id="aof-日志是如何实现的" tabindex="-1"><a class="header-anchor" href="#aof-日志是如何实现的"><span>AOF 日志是如何实现的？</span></a></h3><p>说到日志，我们比较熟悉的是数据库的写前日志（WAL，Write Ahead Log），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复<br> 不过，AOF 日志正好相反，它是写后日志，即 Redis 先执行命令，把数据写入内存，然后才记录日志</p><p>那么，为什么 AOF 要先执行命令再记日志呢？首先我们先来看看 AOF 里记录了什么内容</p><p>传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里面记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的</p><p>我们以 Redis 收到 &quot;set testkey testvalue&quot; 命令后记录的日志为例，看看 AOF 日志的内容<br> 其中，<code>*3</code> 表示当前命令有三个部分，每部分都是由 <code>$+数字</code> 开头，后面紧跟着具体的命令、键或值<br><em>数字表示这部分中的命令、键、值一共有多少字节</em></p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240228221737.png" alt="Redis AOF日志内容" tabindex="0" loading="lazy"><figcaption>Redis AOF日志内容</figcaption></figure><p>但是，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错</p><p>而后写日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用后写日志这一方式的一大好处是，可以避免出现记录错误命令的情况</p><p>除此之外，AOF 还有一个好处，它是在命令执行后才记录日志，所以不会阻塞当前的写操作</p><p>但是 AOF 也有两个潜在的风险</p><ul><li>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险<br> 如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了</li><li>AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险<br> 因为 AOF 日志也是都主线程执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了<br><em>仔细分析的话，这两个风险都是和 AOF 写回磁盘的实际相关的</em><br><em>这意味着如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了</em></li></ul><h3 id="三种写回策略" tabindex="-1"><a class="header-anchor" href="#三种写回策略"><span>三种写回策略</span></a></h3><p>AOF 机制给了我们三个选择，也就是 AOF 配置项 <code>appendfsync</code> 的三个可选项</p><ul><li><code>Always</code>：同步写回，每个写命令执行完，立马同步地将日志写回磁盘</li><li><code>Everysec</code>：每秒写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘</li><li><code>No</code>：操作系统控制的写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</li></ul><p>针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240228223634.png" alt="" loading="lazy"></p><p>到这里，我们就可以根据系统对高性能和高可靠性的要求，来选择使用哪种写回策略了</p><ul><li>想要获得高性能，就选择 <code>no</code> 策略</li><li>想要得到高可靠性保证，就选择 <code>always</code> 策略</li><li>如果允许数据有一点丢失，又希望性能别受太大影响的话，就选择 <code>everysec</code> 策略</li></ul><p>但是，按照系统的性能需求选定了写回策略并不是高枕无忧了<br> 随着接收的写命令越来越多，AOF 文件会越来越大，这也意味着，我们一定要小心 AOF 文件过大带来的性能问题</p><ul><li>文件系统本身对文件大小有限制，无法保存过大的文件</li><li>如果文件过大，之后再往里面追加命令记录的话，效率也会变低</li><li>当发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢</li></ul><p>这时候就需要介绍一下 AOF 的重写机制了</p><h3 id="日志文件太大了怎么办" tabindex="-1"><a class="header-anchor" href="#日志文件太大了怎么办"><span>日志文件太大了怎么办？</span></a></h3><p>简单来说，AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入<br> 比如说，当读取了键值对 <code>testkey：testvalue</code> 之后，重写机制会记录 <code>set testkey testvalue</code> 这条命令</p><p>为什么重写机制可以把日志文件变小呢？实际上，重写机制具有&quot;多变一&quot;功能，也就是说，旧日志文件的多条命令，在重写后的新日志中变成一条命令</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240228224536.png" alt="AOF重写减少日志大小" tabindex="0" loading="lazy"><figcaption>AOF重写减少日志大小</figcaption></figure><p>可以看到上图对一个列表先后做了 6 次修改操作，但是最终只用一条命令就能实现该数据的恢复<br> 对于被修改过成百上千次的键值对来说，重写能节省的空间当然就更大了</p><p><em>不过，虽然 AOF 重写后，日志文件会缩小，但是要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程，这时，我们就需要关注另一个问题：<strong>重写会不会阻塞主线程？</strong></em></p><h3 id="aof-重写会阻塞吗" tabindex="-1"><a class="header-anchor" href="#aof-重写会阻塞吗"><span>AOF 重写会阻塞吗？</span></a></h3><p>与 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的（这也是为了避免阻塞主线程，导致数据库性能下降）</p><p>重写的过程可以总结为&quot;一个拷贝，两处日志&quot;</p><h4 id="一个拷贝" tabindex="-1"><a class="header-anchor" href="#一个拷贝"><span>一个拷贝</span></a></h4><p>每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时 fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据，然后 bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志</p><h4 id="两处日志" tabindex="-1"><a class="header-anchor" href="#两处日志"><span>两处日志</span></a></h4><p>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复</p><p>而第二处日志，指的是新的 AOF 重写日志<br> 这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，就可以用新的 AOF 文件替代旧文件了<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240228225542.png" alt="AOF非阻塞的重写过程" loading="lazy"></p><p>总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后使用两个日志保证在重写过程中，新写入的数据不会丢失，而且因为 Redis 采用额外的线程进行数据重写，所以这个过程并不会阻塞主线程</p>',36)])])}const s=t(c,[["render",a]]),l=JSON.parse(`{"path":"/project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/04_AOF%E6%97%A5%E5%BF%97%EF%BC%9A%E5%AE%95%E6%9C%BA%E4%BA%86%EF%BC%8CRedis%20%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1.html","title":"04_AOF日志：宕机了，Redis 如何避免数据丢失","lang":"zh-CN","frontmatter":{"title":"04_AOF日志：宕机了，Redis 如何避免数据丢失","tag":["Redis"],"category":["Redis 核心技术与实战"],"description":"目前，Redis 的持久化主要有两大机制，即 AOF 日志（Append Only File） 和 RDB 快照 AOF 日志是如何实现的？ 说到日志，我们比较熟悉的是数据库的写前日志（WAL，Write Ahead Log），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复 不过，AOF 日志正好相反，它是写后日志，即 Re...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"04_AOF日志：宕机了，Redis 如何避免数据丢失\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240228221737.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240228223634.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240228224536.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240228225542.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"],["meta",{"property":"og:url","content":"https://logycoconut.github.io/project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/04_AOF%E6%97%A5%E5%BF%97%EF%BC%9A%E5%AE%95%E6%9C%BA%E4%BA%86%EF%BC%8CRedis%20%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"04_AOF日志：宕机了，Redis 如何避免数据丢失"}],["meta",{"property":"og:description","content":"目前，Redis 的持久化主要有两大机制，即 AOF 日志（Append Only File） 和 RDB 快照 AOF 日志是如何实现的？ 说到日志，我们比较熟悉的是数据库的写前日志（WAL，Write Ahead Log），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复 不过，AOF 日志正好相反，它是写后日志，即 Re..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240228221737.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}]]},"git":{"createdTime":1709184530000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":2,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":6.98,"words":2093},"filePathRelative":"project/Redis/Redis 核心技术与实战 - 极客时间/04_AOF日志：宕机了，Redis 如何避免数据丢失.md","autoDesc":true}`);export{s as comp,l as data};
