import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as a,o as t}from"./app-CAtmO8tN.js";const l={};function n(h,i){return t(),e("div",null,[...i[0]||(i[0]=[a(`<p>在 Web 和移动应用的场景中，我们经常需要保存这样一种信息：一个 key 对应一个数据集合</p><ul><li>手机 APP 中的每天的用户登陆信息：一天对应一系列用户 ID 或移动设备 ID</li><li>电商网站上商品的用户评论列表：一个商品对应一系列的评论</li><li>用户在手机 APP 上的签到打卡信息：一天对应一系列用户的签到记录</li><li>应用网站上的网页访问信息：一个网页对应一系列的访问点击</li></ul><p>我们知道，Redis 集合类型的特点就是一个键对应一系列的数据，所以非常适合用来存取这些数据<br> 但是，在这些场景中，除了记录信息，我们往往还需要对集合中的数据进行统计，例如：</p><ul><li>在移动引用中，需要统计每天的新增用户数和第二天的留存用户数</li><li>在电商网站的商品评论中，需要统计评论列表中的最新评论</li><li>在签到打卡中，需要统计一个月内连续打卡的用户数</li><li>在网页访问记录中，需要统计独立访客量（UV，Unique Visitor）</li></ul><p>通常情况下，我们面临的用户数量以及访问量都是巨大的，比如百万、千万级别的用户数量，或者千万级别、甚至亿级别的访问信息<br> 所以，我们必须要选择能够非常高效地统计大量数据的集合类型</p><p><strong>要想选择合适的类型，就得了解常用的集合统计模式</strong><br> 本文将会介绍集合类型常见的四种统计模式，包括聚合统计、排序统计、二值状态统计和基数统计</p><h3 id="聚合统计" tabindex="-1"><a class="header-anchor" href="#聚合统计"><span>聚合统计</span></a></h3><p>所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：</p><ul><li>统计多个集合的共有元素（交集统计）</li><li>把两个集合相比，统计其中一个集合独有的元素（差集统计）</li><li>统计多个集合的所有元素（并集统计）</li></ul><p>在刚才的场景中，统计手机 APP 每天的新增用户数和第二天的留存用户数，正好对应了聚合统计</p><p>要完成这个统计任务，我们可以用一个集合记录所有登录过 APP 的用户 ID，同时，用另一个集合记录每一天登录过 APP 的用户 ID，再这两个集合做聚合统计</p><p>来看具体的操作<br> 记录所有登录过 APP 的用户 ID 还是比较简单的，我们直接使用 Set 类型，把 key 设置为 <code>user：id</code>，表示记录的是用户 ID，value 就是一个 Set 集合，里面是所有登录过 APP 的用户 ID，我们可以把这个 Set 叫作累计用户 Set<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305201628.png" alt="" loading="lazy"></p><p>需要注意的是，累计用户 Set 中没有日期信息，我们是不能直接统计每天的新增用户的<br> 所以，我们还需要把每一天登陆的用户 ID，记录到一个新集合中，我们把这个集合叫作每日用户 Set，它有两个特点</p><ul><li>key 是 <code>user：id</code> 以及当天信息，例如，<code>user:id:20200803</code></li><li>value 是 Set 集合，记录当天登陆的用户 ID<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305201837.png" alt="" loading="lazy"></li></ul><p>在统计每天的新增用户时，只用计算每日用户 Set 和累计用户 Set 的差集就行</p><p>假设我们的手机 App 在 2020 年 8 月 3 日上线，那么，8 月 3 日前是没有用户的。此时，累计用户 Set 是空集，当天登录的用户 ID 会被记录到 key 为 <code>user:id:20200803</code> 的 Set 中。所以，<code>user:id:20200803</code> 这个 Set 中的用户就是当天的新增用户</p><p>然后，我们计算累计用户 Set 和 <code>user:id:20200803</code> Set 的并集结果，结果保存在 user:id 这个累计用户 Set 中，如下所示：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SUNIONSTORE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  user:id</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  user:id</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  user:id:20200803</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此时，user:id 这个累计用户 Set 中就有了 8 月 3 日的用户 ID。等到 8 月 4 日再统计时，我们把 8 月 4 日登录的用户 ID 记录到 <code>user:id:20200804</code> 的 Set 中。接下来，我们执行 SDIFFSTORE 命令计算累计用户 Set 和 <code>user:id:20200804</code> Set 的差集，结果保存在 key 为 <code>user:new</code> 的 Set 中，如下所示：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SDIFFSTORE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  user:new</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  user:id:20200804</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user:id</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以看到，这个差集中的用户 ID 在 <code>user:id:20200804</code> 的 Set 中存在，但是不在累计用户 Set 中。所以，user:new 这个 Set 中记录的就是 8 月 4 日的新增用户</p><p>当要计算 8 月 4 日的留存用户时，我们只需要再计算 <code>user:id:20200803</code> 和 <code>user:id:20200804</code> 两个 Set 的交集，就可以得到同时在这两个集合中的用户 ID 了，这些就是在 8 月 3 日登录，并且在 8 月 4 日留存的用户。执行的命令如下：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SINTERSTORE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user:id:rem</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user:id:20200803</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user:id:20200804</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当你需要对多个集合进行聚合计算时，Set 类型会是一个非常不错的选择<br> 不过，这里有一个潜在的风险</p><p>Set 的差集、并集和交集的计算复杂度较高，在数据量大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞<br> 这边有一个小建议：<strong>你可以从主从集群中选择一个从库，让它专门负责聚合计算，或者把数据读取到客户端，在客户端完成聚合统计</strong><br> 这样就可以规避阻塞主库实例和其他从库实例的风险了</p><h3 id="排序统计" tabindex="-1"><a class="header-anchor" href="#排序统计"><span>排序统计</span></a></h3><p>以在电商网站上提供最新评论列表的场景为例，进行讲解</p><p>最新评论列表包含了所有评论中的最新留言，这就要求<strong>集合类型能对元素保序</strong><br> 也就是说，集合中的元素可以按序排列，这种对元素保序的集合类型叫作有序集合</p><p>在 Redis 常用的 4 个集合类型中（List、Hash、Set、Sorted Set），List 和 Sorted Set 就属于有序集合</p><p><strong>List 是按照元素进入 List 的顺序进行排序的，而 Sorted Set 可以根据元素的权重来排序</strong>，我们可以自己来决定每个元素的权重值<br> 比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大</p><p>看起来好像都可以满足需求，我们该如何选择呢</p><p>先说说用 List 的情况<br> 每个商品对应一个 List，这个 List 包含了对这个商品所有评论，而且会按照评论时间保存这些评论，每来一个新评论，就用 LPUSH 命令把它插入 List 的队头</p><p>在只有一页评论的时候，我们可以很清晰地看到最新的评论，但是，在实际应用中，网站一般会分页显示最新的评论列表，一旦涉及到分页操作，List 就可能会出现问题了</p><p>假设当前的评论 List 是{A, B, C, D, E, F}（其中，A 是最新的评论，以此类推，F 是最早的评论），在展示第一页的 3 个评论时，我们可以用下面的命令，得到最新的三条评论 A、B、C：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">LRANGE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> product1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;A&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;B&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;C&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，再用下面的命令获取第二页的 3 个评论，也就是 D、E、F。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">LRANGE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> product1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 5</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;D&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;E&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;F&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果在展示第二页前，又产生了一个新评论 G，评论 G 就会被 LPUSH 命令插入到评论 List 的队头，评论 List 就变成了{G, A, B, C, D, E, F}。此时，再用刚才的命令获取第二页评论时，就会发现，评论 C 又被展示出来了，也就是 C、D、E。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">LRANGE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> product1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 5</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;C&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;D&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;E&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之所以会这样，关键原因就在于，List 是通过元素在 List 中的位置来排序的，当有一个新元素插入时，原先的元素在 List 中的位置都后移了一位，比如说原来在第 1 位的元素现在在第 2 位<br> 所以，对比新元素插入前后，List 相同位置上的元素就会发生变化，用 LRANGE 读取时，就会读到旧元素</p><p>和 List 相比，Sorted Set 就不存在这个问题，因为它是根据元素的实际权重来排序和获取数据的</p><p>我们可以按评论时间的先后给每条评论设置一个权重值，然后再把评论保存到 Sorted Set 中<br> Sorted Set 的 ZRANGEBYSCORE 命令就可以按权重排序后返回元素<br> 这样，即使集合中的元素频繁更新，Sorted Set 也能通过 ZRANGEBYSCORE 命令准确地获取到按序排列的数据</p><p>假设越新的评论权重越大，目前最新评论的权重是 N，我们执行下面的命令时，就可以获得最新的 10 条评论</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ZRANGEBYSCORE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> comments</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> N-9</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> N</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>所以在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议优先考虑 Sorted Set</p><h3 id="二值状态统计" tabindex="-1"><a class="header-anchor" href="#二值状态统计"><span>二值状态统计</span></a></h3><p>二值状态就是指集合元素的取值就只有 0 和 1 两种<br> 在签到打卡的场景中，我们只用记录签到（1）和未签到（0），所以它就是非常典型的二值状态</p><p>在签到统计中，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型<br> 这个时候，我们就可以选择 BitMap<br> 这是 Redis 提供的扩展数据类型</p><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型<br> String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 Bit 位都利用起来，用来表示一个元素的二值状态<br> 你可以把 Bitmap 看作是一个 bit 数组</p><p>Bitmap 提供了 GETBIT/SETBIT 操作，使用一个偏移值 offset 对 bit 数组的某一个 bit 位进行读和写<br> 不过，需要注意的是，Bitmap 的偏移量是从 0 开始算的，也就是说 offset 的最小值为 0<br> 当使用 SETBIT 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1<br> Bitmap 还提供了 BITCOUNT 操作，用来统计这个 bit 数组中所有&quot;1&quot;的个数</p><p>那么，具体该怎么用 Bitmap 进行签到统计呢？下面借助一个例子来说明</p><p>假设我们要统计 ID 3000 的用户在 2020 年 8 月份的签到情况，就可以按照下面的步骤进行操作</p><p>第一步，执行下面的命令，记录该用户 8 月 3 号已签到。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SETBIT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> uid:sign:3000:202008</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>第二步，检查该用户 8 月 3 日是否签到。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GETBIT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> uid:sign:3000:202008</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>第三步，统计该用户在 8 月份的签到次数。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">BITCOUNT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> uid:sign:3000:202008</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样我们就知道该用户在 8 月份的签到情况了，是不是很简单？<br> 接下来，你可以再思考一个问题：如果记录了一亿个用户 10 天的签到情况，你有办法统计出这 10 天连续签到的用户总数吗？</p><p>在介绍具体的方法之前，我们要先知道，Bitmap 支持用 BITOP 命令对多个 Bitmap 按位做&quot;与&quot;&quot;或&quot;&quot;异或&quot;的操作，操作的结果会保存到一个新的 Bitmap 中</p><p>具体如下，三个 Bitmap bm 1、bm 2、bm 3，对应 bit 位做&quot;与&quot;操作，结果保存到了一个新的 Bitmap 中<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305213421.png" alt="" loading="lazy"></p><p>回到刚才的问题，在统计 1 亿个用户连续 10 天的签到情况时，你可以把每天的日期作为 key，每个 key 对应 1 个 1 亿位的 Bitmap，每一个 bit 对应一个用户当天的签到情况</p><p>接下来，对 10 个 Bitmap 做&quot;与&quot;操作，得到的结果也是一个 Bitmap<br> 在这个 Bitmap 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1<br> 最后，再用 BITCOUNT 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了</p><p>现在，我们可以计算一下记录了 10 天签到情况后的内存开销<br> 每天 1 个 1 亿位的 Bitmap，大约占 12MB 的内存（10^8/8/1024/1024）, 10 天的 Bitmap 内存开销约为 120MB，内存压力不算太大<br> 不过，在实际应用中，最好对 Bitmap 设置过期时间，让 Redis 自动删除不再需要的签到记录，以节省内存开销</p><h3 id="基数统计" tabindex="-1"><a class="header-anchor" href="#基数统计"><span>基数统计</span></a></h3><p>基数统计就是指统计一个集合中不重复的元素个数<br> 对应到我们刚才介绍的场景，就是统计网页的 UV</p><p>网页 UV 的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次<br> 在 Redis 的集合类型中，Set 类型默认支持去重，所以看到有去重需求时，第一时间就会想到用 Set 类型</p><p>结合一个例子来看下</p><p>有一个用户 user 1 访问 page 1 时，你把这个信息加入到 Set 中</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>SADD page1:uv user1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>用户 1 再来访问时，Set 的去重功能就保证了不会重复记录用户 1 的访问次数，这样用户 1 就算是一个独立访客<br> 当你需要统计 UV 时，可以直接用 SCARD 命令，这个命令会返回一个集合中的元素个数</p><p>但是，如果 page 1 非常火爆， UV 达到了千万，这个时候，一个 Set 就要记录千万个用户 ID<br> 对于一个大促的电商网站来说，这样的页面可能有成千上万个，如果每个页面都用这样的一个 Set，就会消耗很大的内存空间</p><p>当然，你也可以用 Hash 类型记录 UV</p><p>例如，你可以把用户 ID 作为 Hash 集合的 key，当用户访问页面时，就用 HSET 命令（用于设置 Hash 集合元素的值），对这个用户 ID 记录一个值&quot;1&quot;，表示一个独立访客，用户 1 访问 page 1 后，我们就记录为 1 个独立访客，如下所示</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>HSET page1:uv user1 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>即使用户 1 多次访问页面，重复执行这个 HSET 命令，也只会把 user 1 的值设置位 1，仍然只记为 1 个独立访客<br> 当要统计 UV 时，我们可以用 HLEN 命令统计 Hash 集合中的所有元素个数</p><p>但是，和 Set 类型相似，当页面很多时，Hash 类型也会消耗很大的内存空间<br> 那么有什么办法既能完成统计，还能节省内存吗？</p><p>这时候，就要用到 Redis 提供的 HyperLogLog 了</p><p>HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素非常多时，它计算基数所需的空间总是固定的，而且还很小</p><p>在 Redis 中，每个 HyperLogLog 只需要花费 12KB 内存，就可以计算接近 2^64 个元素的基数<br><em>和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常省空间</em></p><p>在统计 UV 时，可以用 PFADD 命令把访问页面的每个用户都添加到 HyperLogLog 中</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">PFADD</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> page1:uv</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user3</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user4</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">PFCOUNT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> page1:uv</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%<br> 这也就意味着，使用 HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万<br> 虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型</p>`,85)])])}const d=s(l,[["render",n]]),k=JSON.parse(`{"path":"/project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/11_%E6%9C%89%E4%B8%80%E4%BA%BF%E4%B8%AA%20keys%20%E8%A6%81%E7%BB%9F%E8%AE%A1%EF%BC%8C%E5%BA%94%E8%AF%A5%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9B%86%E5%90%88.html","title":"11_有一亿个 keys 要统计，应该用哪种集合","lang":"zh-CN","frontmatter":{"title":"11_有一亿个 keys 要统计，应该用哪种集合","tag":["Redis"],"category":["Redis 核心技术与实战"],"description":"在 Web 和移动应用的场景中，我们经常需要保存这样一种信息：一个 key 对应一个数据集合 手机 APP 中的每天的用户登陆信息：一天对应一系列用户 ID 或移动设备 ID 电商网站上商品的用户评论列表：一个商品对应一系列的评论 用户在手机 APP 上的签到打卡信息：一天对应一系列用户的签到记录 应用网站上的网页访问信息：一个网页对应一系列的访问点击...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"11_有一亿个 keys 要统计，应该用哪种集合\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305201628.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305201837.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305213421.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"],["meta",{"property":"og:url","content":"https://logycoconut.github.io/project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/11_%E6%9C%89%E4%B8%80%E4%BA%BF%E4%B8%AA%20keys%20%E8%A6%81%E7%BB%9F%E8%AE%A1%EF%BC%8C%E5%BA%94%E8%AF%A5%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9B%86%E5%90%88.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"11_有一亿个 keys 要统计，应该用哪种集合"}],["meta",{"property":"og:description","content":"在 Web 和移动应用的场景中，我们经常需要保存这样一种信息：一个 key 对应一个数据集合 手机 APP 中的每天的用户登陆信息：一天对应一系列用户 ID 或移动设备 ID 电商网站上商品的用户评论列表：一个商品对应一系列的评论 用户在手机 APP 上的签到打卡信息：一天对应一系列用户的签到记录 应用网站上的网页访问信息：一个网页对应一系列的访问点击..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305201628.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}]]},"git":{"createdTime":1709219421000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":4,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":13.78,"words":4135},"filePathRelative":"project/Redis/Redis 核心技术与实战 - 极客时间/11_有一亿个 keys 要统计，应该用哪种集合.md","autoDesc":true}`);export{d as comp,k as data};
