import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as i,o as l}from"./app-mbwvGqXF.js";const a={};function r(c,e){return l(),o("div",null,e[0]||(e[0]=[i('<p>从基础入手，知道 <code>Redis</code> 里面可以存怎么样的数据，对数据可以做怎么样的操作<br> （也就是数据模型和操作接口）<br> 这些看似简单，却是 <code>Redis</code> 缓存、秒杀、分布式锁等场景的重要基础</p><h3 id="可以存哪些数据" tabindex="-1"><a class="header-anchor" href="#可以存哪些数据"><span>可以存哪些数据？</span></a></h3><p>对于键值数据库而言，基本的数据模型是 <code>K-V</code> 模型<br> Key 可以是 String 类型，而 Value 是 String、整型等基本数据类型或其他复杂类型</p><p>不同键值数据库支持的 Key 类型一般差别不大，而 Value 类型则有较大差别<br> 例如，<code>Memcached</code> 支持的 Value 类型仅为 String 类型，而 <code>Redis</code> 支持的 Value 包括了 String、哈希表、列表、集合等</p><p>从使用的角度来说，不同 Value 类型的实现，不仅可以支撑不同业务的数据需求，而且也隐含着不同数据结构在性能、空间效率等方面的差异，从而导致不同的 Value 操作之间存在着差异</p><h3 id="可以对数据做什么操作" tabindex="-1"><a class="header-anchor" href="#可以对数据做什么操作"><span>可以对数据做什么操作？</span></a></h3><p>基本操作无外乎<strong>增删改查</strong><br> 但是在实际执行时，会根据 Key 是否存在而执行相应的新写或更新流程，所以增改可能是一条命令</p><p>在实际业务场景中，可能还会有查询一个用户在一段时间内的访问记录（即 SCAN 操作，根据一段 Key 的范围返回相应的 Value 值）<br> 还可能会在黑白名单应用中，需要判断某个用户是否存在（即 EXISTS 操作，用于判断某个 Key 是否存在）</p><h3 id="采用什么访问模式" tabindex="-1"><a class="header-anchor" href="#采用什么访问模式"><span>采用什么访问模式？</span></a></h3><p>大体来说，一个键值数据库包括了访问框架、索引模块、操作模块和存储模块四部分<br> 访问模式通常有两种</p><ul><li>通过函数库调用的方式供外部应用使用</li><li>通过网络框架以 Socket 通信的形式对外提供键值对操作，这种形式可以提供广泛的键值存储服务（网络框架中包括 Socket Server 和协议解析）</li></ul><p><code>Redis</code> 采用的就是通过网络框架访问<br> 通过网络框架提供键值存储服务，一方面扩大了数据库的受用面，但是也给性能、运行模型提供了不同的设计选择，带来一些潜在的问题</p><p>举个例子，当客户端发送一个如下的命令后，该命令会被封装在网络包中发送到键值数据库<br><code>PUT hello world</code></p><p>键值数据库网络框架接收到网络包，并按照相应的协议进行解析之后，就可以知道，客户端想写入一个键值对，并开始实际的写入流程<br> 此时，我们会遇到一个系统设计上的问题，简单来说，就是网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢？该如何进行设计和取舍呢（<strong>即 I/O 模型设计</strong>）</p><p>举个例子，一个线程既要处理网络连接、解析请求，又要完成数据存取，一旦某一步操作发生阻塞，整个线程就会阻塞住，这就减低了系统响应速度</p><h3 id="如何定位键值对的位置" tabindex="-1"><a class="header-anchor" href="#如何定位键值对的位置"><span>如何定位键值对的位置？</span></a></h3><p>当数据库解析了客户端发来的请求，知道了要进行的键值对操作，此时，数据库需要查找所要操作的键值对是否存在，这依赖于键值数据库的索引模块<br> 索引的作用是让兼职数据库根据 Key 找到相应 Value 的存储位置，进而执行操作</p><p>索引的类型有很多，常见的有哈希表、B+树、字典树等。不同的索引结构在性能、空间消耗、并发控制等方面具有不同的特征</p><p>像 <code>Redis</code> 就是采用哈希表作为 <code>K-V</code> 索引，很大一部分原因在于，其键值数据基本是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表 <code>O(1)</code> 的操作复杂度相匹配</p><h3 id="不同操作的具体逻辑是怎么样的" tabindex="-1"><a class="header-anchor" href="#不同操作的具体逻辑是怎么样的"><span>不同操作的具体逻辑是怎么样的？</span></a></h3><ul><li>对于 GET/SCAN 操作而言，根据 value 的存储位置返回 value 即可</li><li>对于 PUT 一个新的键值对数据而言，数据库需要为该键值对分配内存空间</li><li>对于 DELETE 操作，数据库需要删除键值对并释放相应的内存空间（这个过程由分配器完成）</li></ul><h3 id="如何实现重启后快速提供服务" tabindex="-1"><a class="header-anchor" href="#如何实现重启后快速提供服务"><span>如何实现重启后快速提供服务？</span></a></h3><p>键值数据库虽然依赖于内存保存数据，但如果需要重启后快速重新提供服务，则需要增加持久化功能，将键值数据通过调用本地文件系统的操作接口保存在磁盘上</p><p>但是，在什么时机保存这份数据呢？</p><ul><li>一种方式是，对于每一个键值对，数据库都将其落盘保存到文件中，数据更加可靠，但是会造成很大的性能问题</li><li>另一种方式则是周期性地把数据保存到文件中，这样可以避免频繁写盘操作的性能影响。但是潜在代价就是数据有丢失的风险</li></ul>',25)]))}const p=t(a,[["render",r],["__file","01_一个键值数据库包含什么.html.vue"]]),s=JSON.parse(`{"path":"/project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/01_%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88.html","title":"01_一个键值数据库包含什么","lang":"zh-CN","frontmatter":{"title":"01_一个键值数据库包含什么","tag":["Redis"],"category":["Redis 核心技术与实战"],"description":"从基础入手，知道 Redis 里面可以存怎么样的数据，对数据可以做怎么样的操作 （也就是数据模型和操作接口） 这些看似简单，却是 Redis 缓存、秒杀、分布式锁等场景的重要基础 可以存哪些数据？ 对于键值数据库而言，基本的数据模型是 K-V 模型 Key 可以是 String 类型，而 Value 是 String、整型等基本数据类型或其他复杂类型 ...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/01_%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"01_一个键值数据库包含什么"}],["meta",{"property":"og:description","content":"从基础入手，知道 Redis 里面可以存怎么样的数据，对数据可以做怎么样的操作 （也就是数据模型和操作接口） 这些看似简单，却是 Redis 缓存、秒杀、分布式锁等场景的重要基础 可以存哪些数据？ 对于键值数据库而言，基本的数据模型是 K-V 模型 Key 可以是 String 类型，而 Value 是 String、整型等基本数据类型或其他复杂类型 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"01_一个键值数据库包含什么\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"可以存哪些数据？","slug":"可以存哪些数据","link":"#可以存哪些数据","children":[]},{"level":3,"title":"可以对数据做什么操作？","slug":"可以对数据做什么操作","link":"#可以对数据做什么操作","children":[]},{"level":3,"title":"采用什么访问模式？","slug":"采用什么访问模式","link":"#采用什么访问模式","children":[]},{"level":3,"title":"如何定位键值对的位置？","slug":"如何定位键值对的位置","link":"#如何定位键值对的位置","children":[]},{"level":3,"title":"不同操作的具体逻辑是怎么样的？","slug":"不同操作的具体逻辑是怎么样的","link":"#不同操作的具体逻辑是怎么样的","children":[]},{"level":3,"title":"如何实现重启后快速提供服务？","slug":"如何实现重启后快速提供服务","link":"#如何实现重启后快速提供服务","children":[]}],"git":{"createdTime":1709021000000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":3,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":4.59,"words":1377},"filePathRelative":"project/Redis/Redis 核心技术与实战 - 极客时间/01_一个键值数据库包含什么.md","localizedDate":"2024年2月27日","autoDesc":true}`);export{p as comp,s as data};
