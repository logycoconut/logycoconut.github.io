import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as a,o}from"./app-BsnKshpw.js";const i={};function p(l,e){return o(),t("div",null,e[0]||(e[0]=[a('<blockquote><p><a href="https://mp.weixin.qq.com/s?biz=MzkwNjMwMTgzMQ==&amp;mid=2247490459&amp;idx=1&amp;sn=1e4296228c00aa4203aab481575ac916&amp;chksm=c0ebc373f79c4a658de7ce7f0d8cf30b1f45adb346c2386321779e7cf85a757a12337d3ae233" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s?biz=MzkwNjMwMTgzMQ==&amp;mid=2247490459&amp;idx=1&amp;sn=1e4296228c00aa4203aab481575ac916&amp;chksm=c0ebc373f79c4a658de7ce7f0d8cf30b1f45adb346c2386321779e7cf85a757a12337d3ae233</a></p></blockquote><p>分库分表问题往往要从两条线开始说起<br><mark>垂直方向</mark> 和 <mark>水平方向</mark></p><h3 id="垂直方向" tabindex="-1"><a class="header-anchor" href="#垂直方向"><span>垂直方向</span></a></h3><blockquote><p>垂直方向主要针对的是业务</p></blockquote><h4 id="分表" tabindex="-1"><a class="header-anchor" href="#分表"><span>分表</span></a></h4><p>假设一个简单的电商系统，使用<strong>单库</strong>，目前只存在几张表</p><ul><li>用户表</li><li>订单表</li><li>商品表</li><li>物流表</li></ul><p>此时，一个数据库包含所有的业务表。用户的读、写请求操作的都是同一个数据库</p><p>随着业务的发展，表中的字段会越来越多，开始变得不好维护，一个表包含几十个字段<br><em>比如说需要给用户表增加一些非必要信息字段，但是用户表的数据量有点大，直接改会有风险</em></p><p>这个时候就可以采用分表的策略，将用户表拆分，分为<mark>用户基本信息</mark> 和 <mark>用户扩展信息</mark></p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112114125.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li><code>用户基本信息表</code>：存放用户最主要的信息，比如用户名、密码、手机号、小程序 <code>openId</code>、邮箱等核心数据 <em>（存放查询频次非常高的数据）</em></li><li><code>用户拓展表</code>：存放用户次要信息，比如地址、单位、个性签名等 <em>（这样就不用每次查询用户信息时都要把所有信息查出来了，同时节省了 RPC 的负担）</em></li></ul><p>通过分表把核心数据和非核心数据分开，让表的结构更清晰、职责更加单一、更加便于维护</p><p>像订单表和订单详情表也是一个非常经典的例子</p><h4 id="分库" tabindex="-1"><a class="header-anchor" href="#分库"><span>分库</span></a></h4><p>业务在 N 次迭代后，往往会陷入一个困境，功能非常完善，但是系统关系错综复杂，牵一发而动全身，需要赶紧进行一次内部技术迭代，不然后续会带来很多隐藏问题！</p><p>这个时候就需要按照业务功能划分不同领域，把相同领域的表放在同一个数据库</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112115825.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>按照领域拆分后，每个域只用关注自己相关的表，职责更加单一<br><em>对于代码来说，也可以根据领域拆分出不同的服务</em></p><h4 id="分库分表" tabindex="-1"><a class="header-anchor" href="#分库分表"><span>分库分表</span></a></h4><p>有时候业务上只分库、只分表还是不够的<br> 比如在财务系统的场景上，需要按照月份、年份汇总用户的资金<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112120421.png" alt="image.png" loading="lazy"><br><em>还可以按照区域进行分库，比如华中、华东、华南等等</em></p><h3 id="水平方向" tabindex="-1"><a class="header-anchor" href="#水平方向"><span>水平方向</span></a></h3><blockquote><p>如果说垂直方向更多的是针对业务，那么水平方向更多的是针对数据<br> 也是在面试中说的更多的&quot;分库分表&quot;</p></blockquote><h4 id="单库" tabindex="-1"><a class="header-anchor" href="#单库"><span>单库</span></a></h4><p>还是刚才的单库场景</p><ul><li>用户表</li><li>订单表</li><li>商品表</li><li>物流表</li></ul><p>一个 <code>master</code> 数据库，包含所有的业务表<br> 用户的读写请求操作的都是同一个数据库，适用于并发量很低的场景</p><h4 id="主从读写分离" tabindex="-1"><a class="header-anchor" href="#主从读写分离"><span>主从读写分离</span></a></h4><p>业务发展必然伴随着用户数量的增长<br> 但是一般来说，用户的请求中，<code>读请求</code> 往往占据了大部分，<code>写请求</code> 占比极少</p><p>数据库的连接是有限的，它是非常宝贵的资源<br> 但是不管是读请求，还是写请求也好，它都至少占用一个数据库连接</p><p>那如果写数据需要的连接，被读请求占据完了咋办？不就写不了数据了？</p><p>所以就出现了<code>主从读写分离架构</code>，将读库和写库分开</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112162050.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>如上所示，是最普通的 <code>一主一从架构</code>（一个 <code>master</code>，一个 <code>slave</code>）</p><p>所有的写数据请求，都指向主库<br> 一旦主库写完数据之后，立马异步同步给从库，此时所有的读数据请求，就能获取最新的数据了（网络条件好的情况下几乎忽略不计）</p><p>相较于单库的方案，主从结构更能保证系统的稳定性<br> 如果主库跪了，可以将从库升级为主库</p><p>那么问题来了，如果用户量过大，<code>master</code> 挂了，<code>salve</code> 升级成 <code>master</code> 后还是扛不住怎么办？</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112163316.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>这就需要 <code>一主多从方案</code> 了<br> 如果 <code>master</code> 挂了，可以从从库里选择一个成为新的 <code>master</code>，那么另一个从库就变更成新 <code>master</code> 的 <code>slave</code> 了</p><h4 id="分库-1" tabindex="-1"><a class="header-anchor" href="#分库-1"><span>分库</span></a></h4><p>还是刚才的场景，如果请求量真的很大， <code>master</code> 根本扛不住怎么办 <em>（升级配置哈哈！）</em></p><p>在不升级机器的情况下，可以选择建立多个库<br> 每个库的结构是一模一样的，只有存储的数据不一样</p><h4 id="分表-1" tabindex="-1"><a class="header-anchor" href="#分表-1"><span>分表</span></a></h4><p>根据经验，单表的数据量应该尽量控制在 1000 万以内，这时的性能是最佳的（根据机器配置上下浮动）<br> 当单表的数据超过这个值时，性能会变得很差，比如说索引的检索、建立</p><p>那我们就可以分表，控制每张表的数据量和索引大小</p><p>比如一张数据量很大的用户表<br> 我们将其拆分为</p><ul><li>用户表 0</li><li>用户表 1</li><li>用户表 2</li><li>...<br> 可以通过用户的唯一键去做 <code>hash</code>，确定用户在的那张表，随后进行新增、插入、更新操作</li></ul><h4 id="分库分表-1" tabindex="-1"><a class="header-anchor" href="#分库分表-1"><span>分库分表</span></a></h4><p>将上述两者结合起来，就会得到一个 <code>分库分表</code> 方案<br> 适用于用户并发量很大、而且需要存储的数据量也很多的场景</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112165435.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>当用户请求过来时，先根据用户 <code>唯一键</code> 路由到其中的一个用户库，然后在定位到某张表</p><p>路由的算法有很多</p><ul><li><code>根据 id 取模</code></li><li><code>指定区间 id</code></li><li><code>一致性 hash 算法</code></li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>垂直方向的分库分表更多的是从业务角度出发，为了减少系统的复杂度，将数据区分开</p><p>水平方向的分库分表更多的是为了能让数据在读写中更加丝滑，让数据库更好的发挥性能</p><ul><li><code>分库</code>：解决数据库连接资源不足以及磁盘 IO 性能瓶颈的问题</li><li><code>分表</code>：为了解决单表数据量太大，索引维护困境</li><li><code>分库分表</code>：同时解决以上问题</li></ul><p>根据结论我们在实践中就可以根据具体需要来选择方案</p><ul><li><code>用户并发量很大，但是数据量不大</code>：需要分库，不需要分表</li><li><code>并发量不大，但是数据量很多</code>：需要分表，不需要分库</li></ul>',59)]))}const d=c(i,[["render",p],["__file","为什么需要分库分表？.html.vue"]]),s=JSON.parse(`{"path":"/project/Interview/%E5%9C%BA%E6%99%AF%E9%A2%98/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F.html","title":"为什么需要分库分表","lang":"zh-CN","frontmatter":{"title":"为什么需要分库分表","tag":["数据库","分库分表"],"description":"https://mp.weixin.qq.com/s?biz=MzkwNjMwMTgzMQ==&mid=2247490459&idx=1&sn=1e4296228c00aa4203aab481575ac916&chksm=c0ebc373f79c4a658de7ce7f0d8cf30b1f45adb346c2386321779e7cf85a757a12...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/project/Interview/%E5%9C%BA%E6%99%AF%E9%A2%98/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"为什么需要分库分表"}],["meta",{"property":"og:description","content":"https://mp.weixin.qq.com/s?biz=MzkwNjMwMTgzMQ==&mid=2247490459&idx=1&sn=1e4296228c00aa4203aab481575ac916&chksm=c0ebc373f79c4a658de7ce7f0d8cf30b1f45adb346c2386321779e7cf85a757a12..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112114125.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"分库分表"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么需要分库分表\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112114125.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112115825.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112120421.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112162050.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112163316.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240112165435.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"垂直方向","slug":"垂直方向","link":"#垂直方向","children":[{"level":4,"title":"分表","slug":"分表","link":"#分表","children":[]},{"level":4,"title":"分库","slug":"分库","link":"#分库","children":[]},{"level":4,"title":"分库分表","slug":"分库分表","link":"#分库分表","children":[]}]},{"level":3,"title":"水平方向","slug":"水平方向","link":"#水平方向","children":[{"level":4,"title":"单库","slug":"单库","link":"#单库","children":[]},{"level":4,"title":"主从读写分离","slug":"主从读写分离","link":"#主从读写分离","children":[]},{"level":4,"title":"分库","slug":"分库-1","link":"#分库-1","children":[]},{"level":4,"title":"分表","slug":"分表-1","link":"#分表-1","children":[]},{"level":4,"title":"分库分表","slug":"分库分表-1","link":"#分库分表-1","children":[]}]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1707045882000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":2,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":5.57,"words":1671},"filePathRelative":"project/Interview/场景题/为什么需要分库分表？.md","localizedDate":"2024年2月4日","autoDesc":true}`);export{d as comp,s as data};
