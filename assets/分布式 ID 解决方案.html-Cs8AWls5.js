import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,d as a,o as n}from"./app-BsnKshpw.js";const l={};function t(d,i){return n(),s("div",null,i[0]||(i[0]=[a('<blockquote><p><a href="https://mp.weixin.qq.com/s/GRi2zP-7nlWHFFBzl3G2YQ" target="_blank" rel="noopener noreferrer">京东二面：为什么需要分布式ID？你项目中是怎么做的？</a></p></blockquote><h2 id="什么是分布式-id" tabindex="-1"><a class="header-anchor" href="#什么是分布式-id"><span>什么是分布式 ID</span></a></h2><p><code>ID</code> 就是数据的唯一标识，而 <code>分布式 ID</code> 就是分布式系统下的 <code>ID</code></p><p>举一个简单的例子<br> 业务初期使用的是单机的 <code>MySQL</code>，随着用户的增长，后期可能需要进行分库分表<br> 在分库分表之后，数据就遍布在不同服务器上的数据库了，数据库的自增主键已经没办法满足生成的 <code>主键唯一</code> 了</p><p>这个时候，就需要 <code>分布式 ID</code> 了，保障业务 <code>ID</code> 不冲突</p><p><strong>分布式 ID 需要满足以下几点要求：</strong></p><ul><li><code>全局唯一</code></li><li><code>高性能</code>：生成速度要快，对本地资源消耗要小</li><li><code>高可用</code>：生成 <code>分布式 ID</code> 的服务要保证可用性无限接近 <code>100%</code></li><li><code>安全</code>：不包含敏感信息</li><li><code>有序递增</code>：如果要把 <code>ID</code> 存放在数据库的话，<code>ID</code> 的有序性可以提升数据库的写入速度<br> 有时我们可能需要根据 <code>ID</code> 进行排序</li><li><code>有具体的业务含义</code>：方便问题定位</li><li><code>独立部署</code>：生成 <code>ID</code> 的服务可以和业务相关的服务解耦（虽然带来了网络调用消耗增加的问题，但是总体来说还是很有必要的）</li></ul><h2 id="分布式-id-常见解决方案" tabindex="-1"><a class="header-anchor" href="#分布式-id-常见解决方案"><span>分布式 ID 常见解决方案</span></a></h2><h3 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库"><span>数据库</span></a></h3><h4 id="数据库主键自增" tabindex="-1"><a class="header-anchor" href="#数据库主键自增"><span>数据库主键自增</span></a></h4><p>通过数据库自带的能力来生成 <code>ID</code>，通过一台 <code>MySQL</code> 机器来生成多系统的 <code>分布式 ID</code></p><p>优点在于实现起来简单并且 <code>ID</code> 有序递增<br> 但是缺点也显而易见，支持的并发量不大，每次获取 <code>ID</code> 都要访问一次数据库，增加了对数据库的压力，获取速度也慢，还会暴露自己业务的量级（<code>ID</code> 是数字、有序递增的）</p><h4 id="数据库号段模式" tabindex="-1"><a class="header-anchor" href="#数据库号段模式"><span>数据库号段模式</span></a></h4><p>数据库主键自增这种模式在 ID 需求量大的时候，肯定是不行的<br> 那如果我们批量获取，存在内存里面，需要用的时候直接在内存中拿不就快了吗？</p><p>这就是 <code>基于数据库的号段模式来生成分布式 ID</code></p><p><strong>例如</strong></p><ul><li>创建一个数据库表</li></ul><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE TABLE `sequence_id_generator` (  </span></span>\n<span class="line"><span>  `id` int(10) NOT NULL,  </span></span>\n<span class="line"><span>  `current_max_id` bigint(20) NOT NULL COMMENT &#39;当前最大id&#39;,  </span></span>\n<span class="line"><span>  `step` int(10) NOT NULL COMMENT &#39;号段的长度&#39;,  </span></span>\n<span class="line"><span>  `version` int(20) NOT NULL COMMENT &#39;版本号&#39;,  </span></span>\n<span class="line"><span>  `biz_type`    int(20) NOT NULL COMMENT &#39;业务类型&#39;,  </span></span>\n<span class="line"><span>   PRIMARY KEY (`id`)  </span></span>\n<span class="line"><span>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要通过 <code>current_max_id</code> 和 <code>step</code> 字段来批量获取 <code>ID</code><br> 一次性获取的 <code>ID</code> 范围是：<code>current_max_id ～ current_max_id + step</code></p><ul><li>先插入一行数据</li></ul><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>INSERT INTO `sequence_id_generator` (`id`, `current_max_id`, `step`, `version`, `biz_type`)  </span></span>\n<span class="line"><span>VALUES </span></span>\n<span class="line"><span>(1, 0, 100, 0, 101);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>通过 <code>SELECT</code> 获取指定业务下的批量唯一 <code>ID</code></li></ul><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">id</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> current_max_id</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> step</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> version</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> biz_type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 101</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>不够用的话更新一下即可</li></ul><div class="language-mysql line-numbers-mode" data-highlighter="shiki" data-ext="mysql" data-title="mysql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>\n<span class="line"><span>UPDATE sequence_id_generator SET current_max_id = current_max_id+100, version=version+1 WHERE version = 0  AND `biz_type` = 101  </span></span>\n<span class="line"><span>SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">id</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> current_max_id</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> step</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> version</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> biz_type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 101</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出号段模式对于数据库的访问次数更少，所以数据库的压力也更小</p><h4 id="nosql-redis" tabindex="-1"><a class="header-anchor" href="#nosql-redis"><span>NoSQL（Redis）</span></a></h4><p>通过 <code>Redis</code> 的 <code>incr</code> 命令即可对 <code>id</code> 进行原子顺序递增</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sequence_id_biz_type 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OK</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> incr sequence_id_biz_type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> get sequence_id_biz_type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">&quot;2&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="算法" tabindex="-1"><a class="header-anchor" href="#算法"><span>算法</span></a></h3><h4 id="uuid" tabindex="-1"><a class="header-anchor" href="#uuid"><span>UUID</span></a></h4><p><code>UUID</code> 是 128 位的 16 进制数字（32 个字符），生成规则包含 <code>MAC</code> 地址、时间戳、名字空间（Namespace）、随机数、时序等元素，计算机基于这些规则生成的 <code>UUID</code> 是肯定不会重复的</p><p>看似 <code>UUID</code> 是一个不错的<code>分布式 ID</code>解决方案对吗，但实际上我们很少用它</p><ul><li><code>UUID</code> 的位数太大，需要消耗 128 位，太占空间</li><li><code>UUID</code> 是无顺序的, 插入数据库时会造成很大的压力（<em>主键无序严重影响索引</em> ）</li></ul><h4 id="snowflake-雪花算法" tabindex="-1"><a class="header-anchor" href="#snowflake-雪花算法"><span>Snowflake（雪花算法）</span></a></h4><p>雪花算法是推特开源的分布式 ID 生成算法，由 64 位的 2 进制数字组成</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240118162826.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>除了基本的时间戳、机器信息之外，还有 12 位的序列号，代表了每毫秒可以产生 4096（2^12） 个 <code>ID</code></p><p>雪花算法生成速度快、生成的 ID 有序递增、比较灵活（可以对算法进行简单的改造，例如加入业务 ID），但是可能会有重复 ID 问题（ID 生成依赖时间，但是服务器可能存在时间回拨问题，倒退到之前的时间）</p><p><em>可以了解一下 <code>改良版雪花算法</code>，对上述问题做了一些优化</em></p><h3 id="开源框架" tabindex="-1"><a class="header-anchor" href="#开源框架"><span>开源框架</span></a></h3><ul><li><code>UidGenerator</code> 百度</li><li><code>Leaf</code> 美团</li><li><code>Tinyid</code> 滴滴</li><li>IdGenerator</li></ul>',44)]))}const p=e(l,[["render",t],["__file","分布式 ID 解决方案.html.vue"]]),h=JSON.parse(`{"path":"/project/Interview/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%20ID%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html","title":"分布式 ID 解决方案","lang":"zh-CN","frontmatter":{"title":"分布式 ID 解决方案","tag":["分布式ID"],"description":"京东二面：为什么需要分布式ID？你项目中是怎么做的？ 什么是分布式 ID ID 就是数据的唯一标识，而 分布式 ID 就是分布式系统下的 ID 举一个简单的例子 业务初期使用的是单机的 MySQL，随着用户的增长，后期可能需要进行分库分表 在分库分表之后，数据就遍布在不同服务器上的数据库了，数据库的自增主键已经没办法满足生成的 主键唯一 了 这个时候，...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/project/Interview/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%88%86%E5%B8%83%E5%BC%8F%20ID%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"分布式 ID 解决方案"}],["meta",{"property":"og:description","content":"京东二面：为什么需要分布式ID？你项目中是怎么做的？ 什么是分布式 ID ID 就是数据的唯一标识，而 分布式 ID 就是分布式系统下的 ID 举一个简单的例子 业务初期使用的是单机的 MySQL，随着用户的增长，后期可能需要进行分库分表 在分库分表之后，数据就遍布在不同服务器上的数据库了，数据库的自增主键已经没办法满足生成的 主键唯一 了 这个时候，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240118162826.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"分布式ID"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式 ID 解决方案\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240118162826.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"什么是分布式 ID","slug":"什么是分布式-id","link":"#什么是分布式-id","children":[]},{"level":2,"title":"分布式 ID 常见解决方案","slug":"分布式-id-常见解决方案","link":"#分布式-id-常见解决方案","children":[{"level":3,"title":"数据库","slug":"数据库","link":"#数据库","children":[{"level":4,"title":"数据库主键自增","slug":"数据库主键自增","link":"#数据库主键自增","children":[]},{"level":4,"title":"数据库号段模式","slug":"数据库号段模式","link":"#数据库号段模式","children":[]},{"level":4,"title":"NoSQL（Redis）","slug":"nosql-redis","link":"#nosql-redis","children":[]}]},{"level":3,"title":"算法","slug":"算法","link":"#算法","children":[{"level":4,"title":"UUID","slug":"uuid","link":"#uuid","children":[]},{"level":4,"title":"Snowflake（雪花算法）","slug":"snowflake-雪花算法","link":"#snowflake-雪花算法","children":[]}]},{"level":3,"title":"开源框架","slug":"开源框架","link":"#开源框架","children":[]}]}],"git":{"createdTime":1707045882000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":2,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":3.95,"words":1185},"filePathRelative":"project/Interview/场景题/分布式 ID 解决方案.md","localizedDate":"2024年2月4日","autoDesc":true}`);export{p as comp,h as data};
