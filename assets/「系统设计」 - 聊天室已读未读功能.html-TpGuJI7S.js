import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as r,o as a}from"./app-CRoaDNLO.js";const p={};function i(n,t){return a(),o("div",null,t[0]||(t[0]=[r('<h1 id="「系统设计-」-聊天室已读-未读功能" tabindex="-1"><a class="header-anchor" href="#「系统设计-」-聊天室已读-未读功能"><span>「系统设计 」 - 聊天室已读/未读功能</span></a></h1><p>聊天室大体上可以分为两种</p><ol><li><strong>类似于微信、QQ 这种聊天为主功能的工具</strong></li></ol><p>用户在使用这类聊天工具时，对于聊天内容的需求主要是两点</p><ul><li>跳到最远未读消息</li><li>回到最新消息</li></ul><p>在聊天室中，每条消息都有自己的 ID，并且这些 ID 是顺序递增的<br> 我们只需要为用户记住在聊天室的最后一条消息的最新 ID，并且在关闭聊天窗口时记住当前的最新 ID，就能实现上述需求</p><p>当消息 ID 大于当时记录的最新 ID 时，这些消息都是未读的，否则就是已读的</p><p>并且在聊天室外显示气泡时，也可以根据最新消息 ID 以及当时最新消息 ID 计算得出错过的消息数量</p><ol start="2"><li><strong>类似于钉钉、飞书这些企业管理工具，聊天只是其中一项功能</strong></li></ol><p>对于聊天气泡这种需求方案与上述类似<br> 但在企业管理工具中，还有一项功能，<em>发言人需要知道谁对发送的消息已读了</em></p><p>那这种数据结构我们该如何进行存储呢？<br> 这里推荐一种方式，Redis 的 bitmap（位图）</p><p>每一条消息，都维护一个 bitmap，群里的每一个人都对应 1位<br> 假设群里有 20 人，那发送人发出的消息就对应着有 20 位（可以多留几位，后续可能还会进人）</p><p>接收人在读取消息后，发送一个请求表明已读，服务端接受请求，并将这条消息的接收人对应位标志为 1<br><em>接收人对应哪一位可以根据入群时间进行排序</em></p><p>那么，发送人在查看这条消息的已读/未读消息时，就可以根据这个 bitmap 来进行计算，判断出群里哪些人已读，哪些人未读</p>',14)]))}const m=e(p,[["render",i],["__file","「系统设计」 - 聊天室已读未读功能.html.vue"]]),s=JSON.parse(`{"path":"/inbox/%E3%80%8C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8D%20-%20%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%B7%B2%E8%AF%BB%E6%9C%AA%E8%AF%BB%E5%8A%9F%E8%83%BD.html","title":"「系统设计 」 - 聊天室已读/未读功能","lang":"zh-CN","frontmatter":{"title":"「系统设计 」 - 聊天室已读/未读功能","tag":["聊天室"],"description":"「系统设计 」 - 聊天室已读/未读功能 聊天室大体上可以分为两种 类似于微信、QQ 这种聊天为主功能的工具 用户在使用这类聊天工具时，对于聊天内容的需求主要是两点 跳到最远未读消息 回到最新消息 在聊天室中，每条消息都有自己的 ID，并且这些 ID 是顺序递增的 我们只需要为用户记住在聊天室的最后一条消息的最新 ID，并且在关闭聊天窗口时记住当前的最...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/inbox/%E3%80%8C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8D%20-%20%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%B7%B2%E8%AF%BB%E6%9C%AA%E8%AF%BB%E5%8A%9F%E8%83%BD.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"「系统设计 」 - 聊天室已读/未读功能"}],["meta",{"property":"og:description","content":"「系统设计 」 - 聊天室已读/未读功能 聊天室大体上可以分为两种 类似于微信、QQ 这种聊天为主功能的工具 用户在使用这类聊天工具时，对于聊天内容的需求主要是两点 跳到最远未读消息 回到最新消息 在聊天室中，每条消息都有自己的 ID，并且这些 ID 是顺序递增的 我们只需要为用户记住在聊天室的最后一条消息的最新 ID，并且在关闭聊天窗口时记住当前的最..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"聊天室"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"「系统设计 」 - 聊天室已读/未读功能\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[],"git":{"createdTime":1720772901000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":2,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":1.77,"words":530},"filePathRelative":"inbox/「系统设计」 - 聊天室已读未读功能.md","localizedDate":"2024年7月12日","autoDesc":true}`);export{m as comp,s as data};
