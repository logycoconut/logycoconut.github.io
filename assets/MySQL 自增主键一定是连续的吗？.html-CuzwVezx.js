import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as i,o as l}from"./app-CRoaDNLO.js";const a={};function r(n,e){return l(),o("div",null,e[0]||(e[0]=[i('<h1 id="mysql-自增主键一定是连续的吗" tabindex="-1"><a class="header-anchor" href="#mysql-自增主键一定是连续的吗"><span>MySQL 自增主键一定是连续的吗？</span></a></h1><blockquote><p>自增主键的特点就是<br> 当表中新增一条记录时，主键值会根据自增步长自动叠加，通常会将自增步长设置为 1，也就是说自增主键值是连续的</p></blockquote><h3 id="自增值存储机制" tabindex="-1"><a class="header-anchor" href="#自增值存储机制"><span>自增值存储机制</span></a></h3><ul><li>在 MySQL 5.7 以及之前的版本，自增值保存在内存里<br> 每次重启后，第一次打开表的时候，都会去找自增值的最大值 <code>max (id)</code>，然后将 <code>max (id) + 1</code> 作为这个表当前的自增值</li><li>在 MySQL 8.0 版本，将自增值的变更记录在了 <code>redo log</code> 中，重启的时候依靠 <code>redo log</code> 恢复重启之前的值</li></ul><h3 id="导致自增值不连续的原因" tabindex="-1"><a class="header-anchor" href="#导致自增值不连续的原因"><span>导致自增值不连续的原因</span></a></h3><p>当前， Table A 的 Col B 存在唯一键约束，并且已经存了一条 B=3 的记录了</p><ul><li>唯一键冲突<br> 此时我们继续插入 B=3 的记录，就会出现唯一键冲突插入报错</li></ul><p>但是插入报错并不会将自增值改回去，此时的自增值已经 +1 了，下次插入新值时，对应的 ID 也是自增后的自增值</p><p><em>自增字段值的生成是由存储引擎生成的，而不是优化器完成的，因此，在执行 SQL 语句时，即使未指定自增字段列，也不会对性能产生任何影响</em></p><ul><li><p>事务回滚<br> 很好理解<br> 开启一个事务，并插入 B=4 的记录（此时 id 应该为 4），然后进行回滚<br> 回滚后重新插入 B=4 的记录，此时 ID 为 5</p></li><li><p>批量插入数据</p></li></ul><p>MySQL 在批量插入数据时，会去批量申请 id</p><p>而批量申请 id 的一个策略便是<br><strong>在同一条语句中</strong></p><ul><li>第一次申请，会分配 1 个</li><li>第二次申请，会分配 2 个</li><li>第三次申请，会分配 4 个</li><li>第 n 次申请，会申请 2 的 n-1 次方个</li></ul><p>比如现在有一张新表 Table A，批量插入 5 条数据<br> 那么，在申请 id 时，MySQL 会先申请 1 个，不够，再申请 2 个，还是不够，再申请 4 个，终于够了<br> 5 条新数据，但是自增 id 用了 7 个</p><p>所以，在下一次插入新数据时，自增 id 是从 8 开始的</p>',15)]))}const d=t(a,[["render",r],["__file","MySQL 自增主键一定是连续的吗？.html.vue"]]),m=JSON.parse(`{"path":"/inbox/MySQL%20%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F.html","title":"MySQL 自增主键一定是连续的吗？","lang":"zh-CN","frontmatter":{"title":"MySQL 自增主键一定是连续的吗？","tag":["MySQL"],"description":"MySQL 自增主键一定是连续的吗？ 自增主键的特点就是 当表中新增一条记录时，主键值会根据自增步长自动叠加，通常会将自增步长设置为 1，也就是说自增主键值是连续的 自增值存储机制 在 MySQL 5.7 以及之前的版本，自增值保存在内存里 每次重启后，第一次打开表的时候，都会去找自增值的最大值 max (id)，然后将 max (id) + 1 作为...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/inbox/MySQL%20%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%97%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"MySQL 自增主键一定是连续的吗？"}],["meta",{"property":"og:description","content":"MySQL 自增主键一定是连续的吗？ 自增主键的特点就是 当表中新增一条记录时，主键值会根据自增步长自动叠加，通常会将自增步长设置为 1，也就是说自增主键值是连续的 自增值存储机制 在 MySQL 5.7 以及之前的版本，自增值保存在内存里 每次重启后，第一次打开表的时候，都会去找自增值的最大值 max (id)，然后将 max (id) + 1 作为..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL 自增主键一定是连续的吗？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"自增值存储机制","slug":"自增值存储机制","link":"#自增值存储机制","children":[]},{"level":3,"title":"导致自增值不连续的原因","slug":"导致自增值不连续的原因","link":"#导致自增值不连续的原因","children":[]}],"git":{"createdTime":1719907110000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":2,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":1.97,"words":591},"filePathRelative":"inbox/MySQL 自增主键一定是连续的吗？.md","localizedDate":"2024年7月2日","autoDesc":true}`);export{d as comp,m as data};
