import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,d,o as t}from"./app-BsnKshpw.js";const i={};function r(l,e){return t(),c("div",null,e[0]||(e[0]=[d('<blockquote><p>针对 <code>MySQL</code> 数据库的 <code>innodb</code> 引擎<br> 详细分析请看《MySQL 是怎么运行的：从根儿上理解 MySQL》中的 <a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/24-%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC" target="_blank" rel="noopener noreferrer">MVCC 部分</a></p></blockquote><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><p><code>MVCC</code>（<code>Multi-Version Concurrency Control</code> ，多版本并发控制）<br> 指的是在 <code>RC</code>、<code>RR</code> 隔离级别下执行普通 <code>SELECT</code> 操作时访问记录的版本链的过程，这样子可以使不同事务的 <code>读-写</code>、<code>写-读</code> 操作并发执行，从而提高系统性能</p><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h3><p>核心就在于 <code>undo log</code> 和 <code>ReadView</code>（一致性视图）</p><ul><li>通过<code> undo log</code> 来保存多版本的数据</li><li>通过 <code>ReadView</code> 保存当前活跃的事务列表</li></ul><p>首先我们知道使用 <code>innodb</code> 引擎的表中，它的聚簇索引记录会包含 3 个隐藏列</p><ul><li><code>row_id</code>: 非必需，表中如果存在主键或非 <code>Null</code> 的 <code>Unique</code> 键时不包含：</li><li><code>trx_id</code>：当有事务对某条聚簇索引记录进行改动时，会把该事务的<code>事务 id</code> 赋值给 <code>trx_id</code></li><li><code>roll_pointer</code>：每次对聚簇索引记录进行改动时，都会把旧的版本写入到 <code>undo 日志</code> 中，通过 <code>roll_pointer</code> 这个指针就可以找到该记录修改前的信息<br><em>行的每一次改动都会生成 <code>undo log</code>，久而久之，就会形成一条版本链</em><br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231221143106.png" alt="图片来自 《MySQL是怎么运行的：从根儿上理解 MySQL》" loading="lazy"></li></ul><p>而 <code>ReadView</code> 呢，它最主要的目的就是<strong>判断版本链中的哪个版本是当前事务可见的</strong><br> 它包含 4 个重要的内容</p><ul><li><code>m_ids</code>：生成 <code>ReadView</code> 时，活跃的读写事务的<code>事务 id</code> 列表</li><li><code>min_trx_id</code>：生成 <code>ReadView</code> 时，活跃的读写事务中最小的 <code>事务 id</code>，也就是 <code>m_ids</code> 的最新值</li><li><code>max_trx_id</code>：生成 <code>ReadView</code> 时，系统应该分配给下一个事务的 <code>id</code> 值<br> max_trx_id并不是m_ids中的最大值</li><li><code>creator_trx_id</code>：生成该 <code>ReadView</code> 的事务的 <code>事务 id</code><br> 只有在对表中的记录做改动时（执行 INSERT、DELETE、UPDATE 这些语句时）才会为事务分配事务 id，否则在一个只读事务中的事务 id 值都默认为 0<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231221144107.png" alt="image.png" loading="lazy"></li></ul><p>在执行 <code>SELECT</code> 语句时，<code>innodb</code> 引擎会生成一个 <code>ReadView</code>，随后按照特定的规则决定具体能看到数据的哪个版本</p><ul><li>如果被访问记录的 <code>trx_id</code> 等于 <code>creator_trx_id</code>，则意味着当前事务在访问自己修改过的版本，可以被当前事务访问</li><li>如果被访问记录的 <code>trx_id</code> 小于 <code>min_trx_id</code>，则意味着在查询前事务已经提交，可以被当前事务访问</li><li>如果被访问记录的 <code>trx_id</code> 大于等于 <code>max_trx_id</code>，则意味着在生成 <code>ReaView</code> 后事务才开启，不可以被当前事务访问</li><li>如果被访问记录的 <code>trx_id</code> 在 <code>min_trx_id</code> 与 <code>max_trx_id</code> 之间 <ul><li>在 <code>m_ids</code> 中，事务仍然活跃，不能被访问</li><li>不在 <code>m_ids</code> 中，事务已经被提交，可以被访问</li></ul></li></ul><p>按照这个规则，如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到上一个版本的数据，继续按照上述规则判断可见性，直到最后一个版本</p><h3 id="rc-和-rr-事务隔离级别的区别" tabindex="-1"><a class="header-anchor" href="#rc-和-rr-事务隔离级别的区别"><span>RC 和 RR 事务隔离级别的区别</span></a></h3><p>直接说结论</p><ul><li><code>RC</code>：每次读取数据前都生成一个 <code>ReadView</code></li><li><code>RR</code>：只在事务第一次执行查询语句时才会生成一个 <code>ReadView</code></li></ul><p>所以，<code>RR</code> 隔离级别下，每次查询数据时用的都是同一个 <code>ReadView</code>，才能做到可重复读<br> 而在 <code>RC</code> 隔离级别下，每次查询时，都可能有其他事务正常提交，导致 <code>ReadView</code> 中的 <code>max_trx_id</code> ，<code>m_ids</code> 发生变化，于是可以读取到已经提交的数据</p>',17)]))}const p=o(i,[["render",r],["__file","什么是 MVCC？.html.vue"]]),s=JSON.parse(`{"path":"/project/Interview/MySQL/%E4%BB%80%E4%B9%88%E6%98%AF%20MVCC%EF%BC%9F.html","title":"什么是 MVCC？","lang":"zh-CN","frontmatter":{"title":"什么是 MVCC？","tag":["MySQL"],"description":"针对 MySQL 数据库的 innodb 引擎 详细分析请看《MySQL 是怎么运行的：从根儿上理解 MySQL》中的 MVCC 部分 基本概念 MVCC（Multi-Version Concurrency Control ，多版本并发控制） 指的是在 RC、RR 隔离级别下执行普通 SELECT 操作时访问记录的版本链的过程，这样子可以使不同事务的 ...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/project/Interview/MySQL/%E4%BB%80%E4%B9%88%E6%98%AF%20MVCC%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"什么是 MVCC？"}],["meta",{"property":"og:description","content":"针对 MySQL 数据库的 innodb 引擎 详细分析请看《MySQL 是怎么运行的：从根儿上理解 MySQL》中的 MVCC 部分 基本概念 MVCC（Multi-Version Concurrency Control ，多版本并发控制） 指的是在 RC、RR 隔离级别下执行普通 SELECT 操作时访问记录的版本链的过程，这样子可以使不同事务的 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231221143106.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"什么是 MVCC？\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231221143106.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231221144107.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":3,"title":"实现原理","slug":"实现原理","link":"#实现原理","children":[]},{"level":3,"title":"RC 和 RR 事务隔离级别的区别","slug":"rc-和-rr-事务隔离级别的区别","link":"#rc-和-rr-事务隔离级别的区别","children":[]}],"git":{"createdTime":1703258581000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":2,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":3.26,"words":978},"filePathRelative":"project/Interview/MySQL/什么是 MVCC？.md","localizedDate":"2023年12月22日","autoDesc":true}`);export{p as comp,s as data};
