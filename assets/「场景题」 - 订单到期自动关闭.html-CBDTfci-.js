import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as i,o as l}from"./app-CDs18hrd.js";const r={};function o(s,e){return l(),a("div",null,e[0]||(e[0]=[i(`<h1 id="如何实现订单到期自动关闭" tabindex="-1"><a class="header-anchor" href="#如何实现订单到期自动关闭"><span>如何实现订单到期自动关闭？</span></a></h1><h3 id="定时任务" tabindex="-1"><a class="header-anchor" href="#定时任务"><span>定时任务</span></a></h3><p><strong>定期检查数据库中的订单记录</strong><br> 对于已经创建但未在设定时间内完成支付的订单，系统自动将其状态更新为「已关闭」</p><p>可以使用 <code>elastic-job</code>、<code>xxl-job</code> 等框架</p><p>定时任务这种方式简单有效，但是存在几个问题</p><ul><li>时间精确性<br> 定时任务一般基于固定的时间频率来执行的<br> 那么，就会存在订单已经过期，但还没扫描到，那就导致订单比预期时间晚关闭，存在精度问题<br> 如果定时任务设置的过于频繁，那它可能又会对服务器产生不小的影响</li><li>海量订单处理困难<br> 定时任务不仅精度差，而且一次可能会筛选出来许多符合的数据<br> 数据量一大，处理时间就会变长，导致任务超时</li><li>数据库压力大<br> 短时间内需要处理大量的订单状态更新，可能会导致数据库高负荷甚至暂时的服务拥堵</li></ul><h3 id="rocketmq-延迟消息" tabindex="-1"><a class="header-anchor" href="#rocketmq-延迟消息"><span>RocketMQ 延迟消息</span></a></h3><p>RocketMQ 天然支持延迟消息，如订单支付超时、发送定时通知等<br> 在 RocketMQ 中, 可以很容易地实现消息的延迟投递</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>RocketMQ 并没有直接存储原始的延迟时间，而是提供了几个预定义的延迟级别，每个级别对应一个具体的时间长度</span></span>
<span class="line"><span>当你发送一个延迟消息时，你需要指定这个消息的延迟级别</span></span>
<span class="line"><span>消息被存储在 Broker 上后，并不会立即投递，而是等待特定的时间后才被投递到目标队列</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如，用户创建完订单后，希望在 15 分钟内，如果没有完成支付，就取消订单<br> 那我们在用户创建完订单后，发个延迟 15 分钟的消息，那 15 分钟后，这个消息就会被消费者消费</p><p>但是，RocketMQ 4.x 版本并不支持任意的延迟时间，它只支持 18 个延迟级别，从 1s 到 2h</p><h3 id="delayqueue-java" tabindex="-1"><a class="header-anchor" href="#delayqueue-java"><span>DelayQueue（Java）</span></a></h3><p>DelayQueue 是一个无界阻塞队列，用于放置实现了 Delayed 接口的对象，其中的元素只能在其到期时才能从队列中取出</p><p>这种方案可以做到精确的时间控制，而且线性安全（毕竟都在一个 Java 进程中）<br> 但是 DelayQueue 是无界的，使用不当可能导致内存溢出<br> 而且不适合分布式系统中的应用，重启的时候，排队的任务可能会丢失</p><h3 id="zset-redis" tabindex="-1"><a class="header-anchor" href="#zset-redis"><span>ZSet（Redis）</span></a></h3><blockquote><p>Redis 的有序集合也可以实现订单到期，自动关闭</p></blockquote><ul><li>订单到期时间作为分数（score）<br> 将订单的到期时间戳作为 ZSet 中每个订单的分数，这样就可以通过分数范围查询到期订单</li><li>订单 ID 作为成员（member）</li><li>定期检查过期订单<br> 例如，每分钟执行一个检查任务，查询 ZSet 中分数小于当前时间戳的订单 ID（即已过期的订单）</li><li>关闭过期订单<br> 对于过期订单，执行关闭订单的操作</li></ul><p>这种方式提供高效的查询和操作，Redis 的 ZSet 提供了高效的有序集合数据结构，能够快速执行插入、删除、范围查询等操作，使得对订单到期时间的管理更加高效<br> 借助 Redis 的持久化、高可用机制，也可以避免数据丢失</p><h3 id="hashedwheeltimer-netty" tabindex="-1"><a class="header-anchor" href="#hashedwheeltimer-netty"><span>HashedWheelTimer（Netty）</span></a></h3><p>Netty 中的 HashedWheelTimer 是一种基于时间轮算法的定时器，常用于处理定时任务和延时任务</p><ul><li>创建 HashedWheelTimer 实例，用于执行定时任务</li><li>添加到期任务<br> 当用户下单时，计算订单的过期时间，并将过期任务添加到 HashedWheelTimer 中</li><li>处理到期任务<br> 当到期时间到达时，HashedWheelTimer 会执行相应的任务，这时就可以在任务中执行关闭订单的操作了</li></ul><p>这种方式也较为简单，适合单机场景，但是需要引入额外的组件</p>`,22)]))}const d=t(r,[["render",o],["__file","「场景题」 - 订单到期自动关闭.html.vue"]]),h=JSON.parse(`{"path":"/inbox/%E3%80%8C%E5%9C%BA%E6%99%AF%E9%A2%98%E3%80%8D%20-%20%E8%AE%A2%E5%8D%95%E5%88%B0%E6%9C%9F%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD.html","title":"如何实现订单到期自动关闭？","lang":"zh-CN","frontmatter":{"title":"如何实现订单到期自动关闭？","tag":["场景题"],"description":"如何实现订单到期自动关闭？ 定时任务 定期检查数据库中的订单记录 对于已经创建但未在设定时间内完成支付的订单，系统自动将其状态更新为「已关闭」 可以使用 elastic-job、xxl-job 等框架 定时任务这种方式简单有效，但是存在几个问题 时间精确性 定时任务一般基于固定的时间频率来执行的 那么，就会存在订单已经过期，但还没扫描到，那就导致订单比...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/inbox/%E3%80%8C%E5%9C%BA%E6%99%AF%E9%A2%98%E3%80%8D%20-%20%E8%AE%A2%E5%8D%95%E5%88%B0%E6%9C%9F%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"如何实现订单到期自动关闭？"}],["meta",{"property":"og:description","content":"如何实现订单到期自动关闭？ 定时任务 定期检查数据库中的订单记录 对于已经创建但未在设定时间内完成支付的订单，系统自动将其状态更新为「已关闭」 可以使用 elastic-job、xxl-job 等框架 定时任务这种方式简单有效，但是存在几个问题 时间精确性 定时任务一般基于固定的时间频率来执行的 那么，就会存在订单已经过期，但还没扫描到，那就导致订单比..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"场景题"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何实现订单到期自动关闭？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"定时任务","slug":"定时任务","link":"#定时任务","children":[]},{"level":3,"title":"RocketMQ 延迟消息","slug":"rocketmq-延迟消息","link":"#rocketmq-延迟消息","children":[]},{"level":3,"title":"DelayQueue（Java）","slug":"delayqueue-java","link":"#delayqueue-java","children":[]},{"level":3,"title":"ZSet（Redis）","slug":"zset-redis","link":"#zset-redis","children":[]},{"level":3,"title":"HashedWheelTimer（Netty）","slug":"hashedwheeltimer-netty","link":"#hashedwheeltimer-netty","children":[]}],"git":{"createdTime":1720772901000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":2,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":3.5,"words":1051},"filePathRelative":"inbox/「场景题」 - 订单到期自动关闭.md","localizedDate":"2024年7月12日","autoDesc":true}`);export{d as comp,h as data};
