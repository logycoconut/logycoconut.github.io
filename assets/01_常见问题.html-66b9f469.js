import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c as h,a as e,b as i,d as r,f as o}from"./app-f8f38c45.js";const s={},p=o('<h2 id="java-面向对象编程三大特性-封装、继承、多态" tabindex="-1"><a class="header-anchor" href="#java-面向对象编程三大特性-封装、继承、多态" aria-hidden="true">#</a> Java 面向对象编程三大特性（封装、继承、多态）</h2><ul><li>封装：把一个对象的属性私有化，同时提供能访问这些属性的方法</li><li>继承：继承是使用已存在的类的定义作为基础建立新类，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但是不能选择性的继承父类</li><li>多态：指的是程序中定义的引用变量所指向的具体类型以及该引用对象发出的方法调用并不确定，而是在程序运行期间才确定</li></ul><p>（Java 中有两种形式可以实现多态：继承、接口实现）</p><h2 id="string-为什么是不可变的-string、stringbuffer-和-stringbuilder-的区别是什么" tabindex="-1"><a class="header-anchor" href="#string-为什么是不可变的-string、stringbuffer-和-stringbuilder-的区别是什么" aria-hidden="true">#</a> String 为什么是不可变的？String、StringBuffer 和 StringBuilder 的区别是什么？</h2><ul><li><strong>可变性</strong></li></ul><p>String 类中使用 final 关键字修饰字符数组来保存字符串 <code>private final char value[]</code>，所以String对象是不可变的</p><p>而 StringBuffer 和 StringBuilder 也是用字符数组来保存，但是没有用final修饰，所以是可变的</p><ul><li><strong>线程安全性</strong></li></ul><p>String 中的对象是不可变的，可以理解为常量，所以是线程安全的</p><p>StringBuffer 对方法加了同步锁，所以是线程安全的</p><p>StringBuilder 没有对方法加锁</p><ul><li><strong>性能</strong></li></ul><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象</p><p>StringBuffer 每次都会对本身进行操作</p><p>StringBuilder 因为没有加锁，所以会获得一定的性能提升，但是需要冒线程不安全的风险</p><p><strong>总结</strong></p><ul><li><p>操作少量数据：String</p></li><li><p>单线程操作字符缓冲区下大量数据：StringBuilder</p></li><li><p>多线程操作字符缓冲区下大量数据：StringBuffer</p></li></ul><h2 id="自动装箱与拆箱" tabindex="-1"><a class="header-anchor" href="#自动装箱与拆箱" aria-hidden="true">#</a> 自动装箱与拆箱</h2><p>对于 Integer 来说，通过 valueOf 创建 Integer 对象时，如果值在[-128, 127]之间，便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象，这个范围可以通过 VM 参数更改</p><p>（对于 Integer、Short、Byte、Character、Long 这几个类来说实现是类似的）</p><p>对于 Boolean 来说，内部会定义两个静态类，TRUE、FALSE</p><h2 id="在一个静态方法内调用一个非静态成员为什么是非法的" tabindex="-1"><a class="header-anchor" href="#在一个静态方法内调用一个非静态成员为什么是非法的" aria-hidden="true">#</a> 在一个静态方法内调用一个非静态成员为什么是非法的</h2><p>因为静态方法可以不通过对象进行调用，因此在静态方法内，不能调用其他非静态变量，也不能访问非静态变量成员</p><h2 id="与-equals-重要" tabindex="-1"><a class="header-anchor" href="#与-equals-重要" aria-hidden="true">#</a> == 与 equals（重要）</h2><ul><li><p>== ： 它的作用是判断两个对象的地址是否是相等的，即判断两个对象是不是同一个对象（基本类型比较的是值，引用类型比较的内存地址）</p></li><li><p>equals：它的作用也是判断对象是否相等，但是分为两种情况</p><ul><li><p>没有覆盖 equals 方法：默认使用 == 比较</p></li><li><p>覆盖 equals 方法：可以自己实现来比较两个对象是否相同，如果内容相同则返回 true</p></li></ul></li></ul><p><strong>说明</strong></p><ul><li><p>String 的 equals 被重写过，比较的是对象的值</p></li><li><p>创建 String 对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把地址赋给当前引用，如果没有则在常量池中重新创建一个对象</p></li></ul><h2 id="hashcode-和-equals-重要" tabindex="-1"><a class="header-anchor" href="#hashcode-和-equals-重要" aria-hidden="true">#</a> hashCode 和 equals（重要）</h2><ol><li>hashCode()介绍</li></ol><p>继承自 Object 的 hashCode 方法是本地方法，该方法通常用来将对象的内存地址转换成整数后返回</p><ol start="2"><li>为什么要有 hashCode</li></ol><p>hashCode 通常用在 Hash 数据结构确定位置</p><p>例如 HashSet，对象在加入 HashSet 时，会先计算对象的 hashCode 来判断加入位置，同时也会和其他 hashCode 做比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现过</p><p>但是如果发现有相同的 hashCode 值的对象，这时会调用 equals 方法判断是否真的相同。如果相同加入就不会成功</p><ol start="3"><li>为什么重写 equals 时必须要重写 hashCode 方法？</li></ol><p>因为两个对象如果相同，那他们的 hashCode 也一定是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true</p><p><em>hashCode 的默认行为是对堆上的对象产生独特值，如果没有重写 hashCode 方法，那么 hashCode 无论如何也不会相等</em></p><ol start="4"><li>为什么两个对象具有相同的hashCode值，他们也不一定是相同的？</li></ol><p>hashCode 所使用的杂凑算法也许刚好让多个对象返回相同的杂凑值，越糟糕的算法越容易碰撞</p><p><strong>hashCode 只是用来缩小查找成本，equals 用来判断是否真的相同</strong></p><h2 id="bio、nio、aio-有什么区别" tabindex="-1"><a class="header-anchor" href="#bio、nio、aio-有什么区别" aria-hidden="true">#</a> BIO、NIO、AIO 有什么区别？</h2><ul><li>BIO（Blocking I/O）：同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成</li></ul><p>在活动连接数不是特别高（小于1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或者请求。</p><p><strong>线程发起 IO 请求后，一直阻塞 IO，直到缓冲区数据准备就绪后，在进入下一步操作</strong></p><ul><li>NIO（Non-Blocking / New I/O）:同步非阻塞 I/O 模型。线程发起 IO 请求后，立即返回</li></ul><p>同步指的是必须等待 IO 缓冲区的数据就绪，而非阻塞指的是，用户线程不原地等待 IO 缓冲区，可以先做一些其他操作，但是要定时轮询检查 IO 缓冲区是否就绪</p><p><strong>Java 中的 NIO 是 New IO 的意思，其实是 NIO + IO 多路复用技术。普通的 NIO 查询是线程轮询查看一个 IO 缓冲区是否就绪，而 Java 中的 NewIO 指的是线程轮询查看一批 IO 缓冲区是否就绪，这就是 IO 多路复用的思想。IO 多路复用模型中，将检查 IO 数据是否就绪的任务交给系统级别的 select 或 epoll 模型，有系统进行监控，减轻用户线程负担</strong></p><ul><li>AIO（Asynchronous）：真正意义上的异步非阻塞模型。上述 IO 实现中，需要用户线程定时轮询，去检查 IO 缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些 IO 就绪。真正理想的异步非阻塞 IO 应该让系统完成，用户只需要告诉系统，当缓冲区就绪后，通知我或者执行我交给你的回调函数</li></ul><h3 id="java-中的-io-原理" tabindex="-1"><a class="header-anchor" href="#java-中的-io-原理" aria-hidden="true">#</a> Java 中的 IO 原理</h3><p>Java 中的 IO 都是依赖操作系统内核进行的，我们程序中的 IO 读写其实调用的是操作系统内核中的 read&amp;write 两大系统调用</p><p>内核是怎么进行 IO 交互的？</p><ol><li>网卡收到网络数据，并将网络数据写到内存中</li><li>当网卡把数据写到内存后，网卡向 CPU 发出一个中断请求，操作系统便能得知有新数据来，再通过网卡中断程序去处理数据</li><li>将内存中的数据写入到对应 socket 的缓冲区中</li><li>当缓冲区的数据写好之后，应用程序开始进行数据处理</li></ol><h3 id="同步和异步" tabindex="-1"><a class="header-anchor" href="#同步和异步" aria-hidden="true">#</a> 同步和异步</h3><p>同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行</p><p>同步和异步关注的是方法的执行方是主线程还是其他线程，主线程的话需要等待方法执行完成，其他线程无需等待立刻返回方法调用，主线程可以直接执行接下来的代码</p><h3 id="阻塞与非阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞与非阻塞" aria-hidden="true">#</a> 阻塞与非阻塞</h3><p>阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作</p><h3 id="举个例子" tabindex="-1"><a class="header-anchor" href="#举个例子" aria-hidden="true">#</a> 举个例子</h3><blockquote><p>烧一壶水需要半个小时</p></blockquote><ul><li><p>A 去烧水，就这样干等了半个小时，然后开始喝热水（BIO）</p></li><li><p>B 去烧水，但是需要等半个小时，于是去做其他事情，时不时的过来看水有没有烧好。在这段时间内，他既做了其他事情，也烧好了水（NIO）</p></li><li><p>C 买了一个高级水壶，水烧开之后会发出叫声，于是 C 不用干等着，也不用时不时的过来看，因为水开了他会听到，最后也喝上了热水（AIO）</p></li></ul>',60),d={href:"https://juejin.cn/post/6844903985158045703#heading-0",target:"_blank",rel:"noopener noreferrer"},u={href:"https://juejin.cn/post/6939841279329042439",target:"_blank",rel:"noopener noreferrer"};function c(g,I){const a=n("ExternalLinkIcon");return t(),h("div",null,[p,e("p",null,[e("a",d,[i("如何理解BIO、NIO、AIO的区别"),r(a)])]),e("p",null,[e("a",u,[i("常见的 IO 模型有哪些？Java 中的 BIO、NIO、AIO 有啥区别？ - JavaGuide"),r(a)])])])}const _=l(s,[["render",c],["__file","01_常见问题.html.vue"]]);export{_ as default};
