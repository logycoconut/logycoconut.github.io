import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as n,o as e}from"./app-BsnKshpw.js";const l={};function t(p,a){return e(),i("div",null,a[0]||(a[0]=[n(`<h2 id="arraylist-和-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#arraylist-和-linkedlist-的区别"><span>ArrayList 和 LinkedList 的区别</span></a></h2><ul><li><p><strong>是否保证线程安全</strong>：二者都是不同步的，都不保证线程安全</p></li><li><p><strong>底层数据结构</strong>：ArrayList 底层是 Object[]数组；LinkedList 底层用的是双向链表</p></li><li><p><strong>插入和删除是否受元素位置的影响</strong>：</p><ul><li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li></ul><p>比如：执行 add(E e)方法时，会默认将指定的元素追加到此列表的末尾，这种时间复杂度就是 O(1)，但是如果要在指定位置增加元素的话，时间复杂度就是 O(n-i)，因为其余位置的元素都需要向后移动一位</p><ul><li>LinkedList 采用链表存储，所以对于 add(E e)方法来说，复杂度也近似 O(1)，如果是要在指定位置插入元素的话，时间复杂度就近似 O(n)，因为需要先移动到指定位置</li></ul></li><li><p><strong>是否支持快速随机访问</strong>：ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素</p></li><li><p><strong>内存空间占用</strong>：ArrayList 的空间浪费主要体现在 list 的结尾会预留一定的容量空间，而 LinkedList 的空间话费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继、直接前驱以及数据）</p></li></ul><h3 id="randomaccess接口" tabindex="-1"><a class="header-anchor" href="#randomaccess接口"><span>RandomAccess接口</span></a></h3><p>ArrayList 实现了此接口，RandomAccess 接口只是一个标识，标识这个类具有随机访问的功能</p><p>在 <code>binarySearch()</code> 方法中，他会判断传入的 list 是否实现 RandomAccess，如果是则调用 <code>indexedBinarySearch()</code> 方法，否则调用 <code>iteratorBinarySearch()</code></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public static &lt;T&gt;</span></span>
<span class="line"><span>int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) {</span></span>
<span class="line"><span>    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span></span>
<span class="line"><span>        return Collections.indexedBinarySearch(list, key);</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        return Collections.iteratorBinarySearch(list, key);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="arraylist的扩容机制" tabindex="-1"><a class="header-anchor" href="#arraylist的扩容机制"><span>ArrayList的扩容机制</span></a></h2><h3 id="arraylist的构造函数" tabindex="-1"><a class="header-anchor" href="#arraylist的构造函数"><span>ArrayList的构造函数</span></a></h3><p>默认无参构造函数实际上初始化了一个空数组，当真正对数组进行添加元素操作时，才真正分配容量</p><p>即向数组中添加第一个元素时，数组扩容为 10</p><h3 id="代码解析-java8" tabindex="-1"><a class="header-anchor" href="#代码解析-java8"><span>代码解析（Java8）</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 添加元素</span></span>
<span class="line"><span>public boolean add(E e) {</span></span>
<span class="line"><span>    ensureCapacityInternal(size + 1);  // Increments modCount!!</span></span>
<span class="line"><span>    elementData[size++] = e;</span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private void ensureCapacityInternal(int minCapacity) {</span></span>
<span class="line"><span>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 获取最小扩容量</span></span>
<span class="line"><span>private static int calculateCapacity(Object[] elementData, int minCapacity) {</span></span>
<span class="line"><span>    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span></span>
<span class="line"><span>        return Math.max(DEFAULT_CAPACITY, minCapacity);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return minCapacity;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 判断是否需要扩容</span></span>
<span class="line"><span>private void ensureExplicitCapacity(int minCapacity) {</span></span>
<span class="line"><span>    modCount++;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // overflow-conscious code</span></span>
<span class="line"><span>    if (minCapacity - elementData.length &gt; 0)</span></span>
<span class="line"><span>        grow(minCapacity);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 核心扩容方法</span></span>
<span class="line"><span>private void grow(int minCapacity) {</span></span>
<span class="line"><span>    // 记录旧容量</span></span>
<span class="line"><span>    int oldCapacity = elementData.length;</span></span>
<span class="line"><span>    // 计算新容量，结果等于旧容量的1.5倍</span></span>
<span class="line"><span>    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span></span>
<span class="line"><span>    if (newCapacity - minCapacity &lt; 0)</span></span>
<span class="line"><span>        newCapacity = minCapacity;</span></span>
<span class="line"><span>    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span></span>
<span class="line"><span>        newCapacity = hugeCapacity(minCapacity);</span></span>
<span class="line"><span>    // minCapacity is usually close to size, so this is a win:</span></span>
<span class="line"><span>    elementData = Arrays.copyOf(elementData, newCapacity);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="system-arraycpoy-和-arrays-copyof-方法" tabindex="-1"><a class="header-anchor" href="#system-arraycpoy-和-arrays-copyof-方法"><span>System.arraycpoy()和 Arrays.copyOf()方法</span></a></h3><ul><li>Arrays.copyOf：主要用于给原数组扩容，内部会新建一个数组，并返回该数组</li><li>System.arraycopy：将原数组拷贝到你自己定义的数组里或原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>
<span class="line"><span>- 复制数组</span></span>
<span class="line"><span>- @param src 源数组</span></span>
<span class="line"><span>- @param srcPos 源数组中的起始位置</span></span>
<span class="line"><span>- @param dest 目标数组</span></span>
<span class="line"><span>- @param destPos 目标数组中的起始位置</span></span>
<span class="line"><span>- @param length 要复制的数组元素的数量</span></span>
<span class="line"><span>*/</span></span>
<span class="line"><span>public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ensurecapacity-和-ensurecapacityinternal" tabindex="-1"><a class="header-anchor" href="#ensurecapacity-和-ensurecapacityinternal"><span>ensureCapacity 和 ensureCapacityInternal</span></a></h3><p>顾名思义，ensureCapacityInternal 是用户 ArrayList 内部调用的，ensureCapacity 是给外部调用的。当我们需要大量插入元素时，可以先调用 ensureCapacity 方法扩容，这样可以减少在增加元素过程中重新分配的次数</p><h2 id="hashmap-与-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#hashmap-与-hashtable-的区别"><span>HashMap 与 HashTable 的区别</span></a></h2><ol><li><p>线程是否安全：HashMap 是非线程安全的，HashTable 是线程安全的，因为 HashTable 内部的方法基本都经过 synchronized 修饰</p></li><li><p>效率：因为线程安全的问题，HashMap 要比 HashTable 效率高一点</p></li><li><p>对 Null Key 和 Null Value 的支持：HashMap 支持，HashTable 不允许 Null，否则会抛出 NullPointException</p></li><li><p>初始容量大小和每次扩容大小的不同：</p><ul><li><p>如果不指定初始值</p><ul><li><p>Hashtable 的默认大小为11，之后每次扩容为原来的2n+1</p></li><li><p>HashMap 的默认大小为16，之后每次扩容为原来的2倍</p></li></ul></li><li><p>如果给定了初始值</p><ul><li><p>HashTable 会直接使用给定的初始值</p></li><li><p>HashMap 会将其扩充为2的幂次方</p></li></ul></li></ul></li><li><p>底层数据结构：jdk1.8之后的 HashMap，当链表长度大于阈值（默认为8）时（将链表转换成红黑树之前会判断当前数组的长度，如果小于64，那么会选择数组扩容，而不是转换成红黑树），将链表转化成红黑树，以减少搜索时间</p></li></ol><h3 id="tablesizefor-保证-hashmap-的大小总为-2-的幂次方" tabindex="-1"><a class="header-anchor" href="#tablesizefor-保证-hashmap-的大小总为-2-的幂次方"><span>tableSizeFor 保证 HashMap 的大小总为 2 的幂次方</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> tableSizeFor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cap) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cap </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;&gt;&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;&gt;&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;&gt;&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;&gt;&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;&gt;&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> MAXIMUM_CAPACITY) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> MAXIMUM_CAPACITY </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法的作用就是将当前数字 -1 后的结果 n 最高位后面的位都填充 1，得到的最后结果 +1 就会将最高位又进 1</p><p><strong>举个例子</strong></p><p>Cap = 5</p><p>N = 4，也既是 00000100</p><p>它的最后结果就是 00000111，也就是 7</p><p>最后 +1 进位，返回最终结果 8</p><h2 id="hashmap和hashset的区别" tabindex="-1"><a class="header-anchor" href="#hashmap和hashset的区别"><span>HashMap和HashSet的区别</span></a></h2><table><thead><tr><th>类型</th><th>存储内容</th><th>存放方式</th><th>hashCode 计算方式</th></tr></thead><tbody><tr><td>HashMap</td><td>存储键值对</td><td>调用 put 添加元素</td><td>使用键来计算 hashCode</td></tr><tr><td>HashSet</td><td>仅存储对象</td><td>调用 add 增加元素</td><td>使用成员对象来计算 hashCode</td></tr></tbody></table><h2 id="hashmap的底层实现" tabindex="-1"><a class="header-anchor" href="#hashmap的底层实现"><span>HashMap的底层实现</span></a></h2><ul><li>Java8 之前</li></ul><p>底层是数组和链表结合在一起使用的链表散列</p><p>HashMap 通过 key 的 hashCode 经过扰动函数处理后得到 hash 值，然后通过 <code>(n-1)&amp;hash</code> 计算当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同的话就通过拉链法解决</p><p><strong>扰动函数：</strong> 其实就是 HashMap 的 hash 方法，使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode 方法，换句话说，使用扰动函数之后可以减少碰撞</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>static final int hash(Object key) {</span></span>
<span class="line"><span>    int h;</span></span>
<span class="line"><span>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>拉链法：</strong> 就是创建一个链表数组，数组中每一格就是一个链表，若遇到 hash 冲突，则将冲突的值加到链表中即可</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/hash map 拉链法.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>Java8之后</li></ul><p>当链表长度大于阈值时（默认为8），将链表转换为红黑树，以减少搜索时间（转换前会判断当前数组的长度，如果小于64，那么会选择先将数组扩容）</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/hash map 链表转红黑树.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="hashmap的长度为什么是2的幂次方" tabindex="-1"><a class="header-anchor" href="#hashmap的长度为什么是2的幂次方"><span>HashMap的长度为什么是2的幂次方</span></a></h2><p>Hash 值的范围在-2<sup>31～2</sup>31-1之间，前后加起来大概40亿的映射空间，这样的数组内存是放不下的，所以我们还需要对数组长度取模运算，得到的余数就是要存放的位置，也就是数组下标</p><p>计算方式就是 <code>hash%n</code>，但是如果除数是2的幂次方的话，那么 <code>hash%n</code> 就等价于 <code>(n-1)&amp;hash</code></p><p>采用与操作相对于%操作来说会提高运算效率，这就解释了为什么 HashMap 的长度为什么是 2的幂次方</p><h2 id="hashmap-多线程操作导致死循环-java8之前" tabindex="-1"><a class="header-anchor" href="#hashmap-多线程操作导致死循环-java8之前"><span>HashMap 多线程操作导致死循环（Java8之前）</span></a></h2><p><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener noreferrer">JAVA HASHMAP的死循环</a></p><h2 id="concurrenthashmap-线程安全的具体实现方式" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-线程安全的具体实现方式"><span>ConcurrentHashMap 线程安全的具体实现方式</span></a></h2><ul><li>JDK1.7</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/1646558557818-b1756d84-8038-4624-b0ff-0db34cb7fc8c.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问</p><p>ConcurrentHashMap 是由 Segment 和 HashEntry 组成</p><p>Segment 实现了 ReentrantLock，所以 Segment 时一种可重入锁</p><p>一个 ConcurrentHashMap 包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 的元素，当对 HashEntry 修改时，必须获得对应的 Segment 锁</p><ul><li>JDK1.8</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/ConcurrentHashMap java8 锁.png" alt="i" tabindex="0" loading="lazy"><figcaption>i</figcaption></figure><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构也是数组+链表/红黑树的形式，Java8在链表长度超过一定阈值时将链表(O(N))转换成红黑树（O (logN)）</p><p>synchronized 只锁定当前链表或者红黑树的首节点，所以只要 hash 不冲突，就不会产生并发</p>`,57)]))}const c=s(l,[["render",t],["__file","01_常见问题.html.vue"]]),d=JSON.parse(`{"path":"/resource/code/01_java/02_%E9%9B%86%E5%90%88/01_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html","title":"常见问题","lang":"zh-CN","frontmatter":{"title":"常见问题","date":"2022-02-26T00:00:00.000Z","tag":["Java"],"description":"ArrayList 和 LinkedList 的区别 是否保证线程安全：二者都是不同步的，都不保证线程安全 底层数据结构：ArrayList 底层是 Object[]数组；LinkedList 底层用的是双向链表 插入和删除是否受元素位置的影响： ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响 比如：执行 add(E e)方法时，...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/resource/code/01_java/02_%E9%9B%86%E5%90%88/01_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"常见问题"}],["meta",{"property":"og:description","content":"ArrayList 和 LinkedList 的区别 是否保证线程安全：二者都是不同步的，都不保证线程安全 底层数据结构：ArrayList 底层是 Object[]数组；LinkedList 底层用的是双向链表 插入和删除是否受元素位置的影响： ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响 比如：执行 add(E e)方法时，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/hash%20map%20%E6%8B%89%E9%93%BE%E6%B3%95.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-02-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"常见问题\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/hash%20map%20%E6%8B%89%E9%93%BE%E6%B3%95.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/hash%20map%20%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/1646558557818-b1756d84-8038-4624-b0ff-0db34cb7fc8c.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/java/ConcurrentHashMap%20java8%20%E9%94%81.png\\"],\\"datePublished\\":\\"2022-02-26T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"ArrayList 和 LinkedList 的区别","slug":"arraylist-和-linkedlist-的区别","link":"#arraylist-和-linkedlist-的区别","children":[{"level":3,"title":"RandomAccess接口","slug":"randomaccess接口","link":"#randomaccess接口","children":[]}]},{"level":2,"title":"ArrayList的扩容机制","slug":"arraylist的扩容机制","link":"#arraylist的扩容机制","children":[{"level":3,"title":"ArrayList的构造函数","slug":"arraylist的构造函数","link":"#arraylist的构造函数","children":[]},{"level":3,"title":"代码解析（Java8）","slug":"代码解析-java8","link":"#代码解析-java8","children":[]},{"level":3,"title":"System.arraycpoy()和 Arrays.copyOf()方法","slug":"system-arraycpoy-和-arrays-copyof-方法","link":"#system-arraycpoy-和-arrays-copyof-方法","children":[]},{"level":3,"title":"ensureCapacity 和 ensureCapacityInternal","slug":"ensurecapacity-和-ensurecapacityinternal","link":"#ensurecapacity-和-ensurecapacityinternal","children":[]}]},{"level":2,"title":"HashMap 与 HashTable 的区别","slug":"hashmap-与-hashtable-的区别","link":"#hashmap-与-hashtable-的区别","children":[{"level":3,"title":"tableSizeFor 保证 HashMap 的大小总为 2 的幂次方","slug":"tablesizefor-保证-hashmap-的大小总为-2-的幂次方","link":"#tablesizefor-保证-hashmap-的大小总为-2-的幂次方","children":[]}]},{"level":2,"title":"HashMap和HashSet的区别","slug":"hashmap和hashset的区别","link":"#hashmap和hashset的区别","children":[]},{"level":2,"title":"HashMap的底层实现","slug":"hashmap的底层实现","link":"#hashmap的底层实现","children":[]},{"level":2,"title":"HashMap的长度为什么是2的幂次方","slug":"hashmap的长度为什么是2的幂次方","link":"#hashmap的长度为什么是2的幂次方","children":[]},{"level":2,"title":"HashMap 多线程操作导致死循环（Java8之前）","slug":"hashmap-多线程操作导致死循环-java8之前","link":"#hashmap-多线程操作导致死循环-java8之前","children":[]},{"level":2,"title":"ConcurrentHashMap 线程安全的具体实现方式","slug":"concurrenthashmap-线程安全的具体实现方式","link":"#concurrenthashmap-线程安全的具体实现方式","children":[]}],"git":{"createdTime":1676991217000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":6,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":7.3,"words":2189},"filePathRelative":"resource/code/01_java/02_集合/01_常见问题.md","localizedDate":"2022年2月26日","autoDesc":true}`);export{c as comp,d as data};
