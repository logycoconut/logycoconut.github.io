import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as e,o as s}from"./app-I68t-fKX.js";const n={};function l(k,i){return s(),a("div",null,i[0]||(i[0]=[e(`<blockquote><p><a href="https://www.bilibili.com/video/BV1Zy411e7qY/?share_source=copy_web&amp;vd_source=d3cf8d37233f4f5206017ef71b7071e8" target="_blank" rel="noopener noreferrer">Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？ - 小白 debug</a></p></blockquote><h1 id="kafka-为什么这么快-rocketmq-哪里不如-kafka" tabindex="-1"><a class="header-anchor" href="#kafka-为什么这么快-rocketmq-哪里不如-kafka"><span>Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？</span></a></h1><p>RocketMQ 在设计上参考了 Kafka，架构上更简单，功能更加丰富<br> 看起来似乎是 RocketMQ 更加能打</p><p>但是 Kafka 一直没有被淘汰，说明 RocketMQ 必然有着不如 Kafka 的地方<br> 是什么呢？</p><p><strong>性能！严格来说是吞吐量</strong><br> 数据显示，RocketMQ 每秒能处理 10W 量级的数据，而 Kafka 则是 17W<br><em>快则快矣，但其实也并没有拉开量级的性能差距</em></p><h3 id="消息从消息队列的磁盘发送到消费者-过程是怎么样的" tabindex="-1"><a class="header-anchor" href="#消息从消息队列的磁盘发送到消费者-过程是怎么样的"><span>消息从消息队列的磁盘发送到消费者，过程是怎么样的？</span></a></h3><p>消息队列的进程为了防止进程崩溃后丢失消息，一般不会放在内存里，而是放在磁盘上</p><p>操作系统分为用户空间和内核空间<br> 程序处于用户空间，硬盘则属于硬件<br> 操作系统本质上就是程序和硬件之间的中间层，程序需要通过操作系统去调用硬件能力</p><p>如果用户想要将数据从磁盘（消息实际存储的地方）发送到网络（消费者），一般来说会经过这么几个步骤</p><ul><li>程序发起 read () 请求，消息从磁盘拷贝到内核空间中的内核缓冲区</li><li>消息从内核缓冲区拷贝到用户空间的用户缓冲区</li><li>程序发起系统调用 write () 请求，消息从用户缓冲区拷贝到内核空间的 socket 缓冲区</li><li>最后，消息从 socket 缓冲区拷贝到网卡上，发送到网络中，最终到达消费者<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809145531.png" alt="" loading="lazy"></li></ul><p><strong>整个过程总共有 2 次系统调用、4 次用户空间和内核空间的切换、4 次数据拷贝</strong><br> 同样一份数据来回拷贝，效率低下</p><h3 id="零拷贝技术" tabindex="-1"><a class="header-anchor" href="#零拷贝技术"><span>零拷贝技术</span></a></h3><p>常见的方案有两种，分别是 mmap 和 sendfile</p><h4 id="mmap" tabindex="-1"><a class="header-anchor" href="#mmap"><span>mmap</span></a></h4><p>mmap 是操作系统提供的一个方法，可以将内核空间的缓冲区映射到用户空间</p><p>使用它后，上文提到的发送流程就会产生变化</p><ul><li>程序发起 mmap () 请求，消息从磁盘拷贝到内核空间中的内核缓冲区</li><li>消息从内核缓冲区<strong>映射</strong>到用户空间的用户缓冲区（这里不需要拷贝）</li><li>程序发起系统调用 write () 请求，消息从内核缓冲区拷贝到内核空间的 socket 缓冲区</li><li>最后，消息从 socket 缓冲区拷贝到网卡上，发送到网络中，最终到达消费者<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809150526.png" alt="" loading="lazy"></li></ul><p><strong>整个过程总共有 2 次系统调用、4 次用户空间和内核空间的切换、3 次数据拷贝</strong><br><strong>省下了 1 次数据拷贝</strong></p><p><em>相信大家也发现了，零拷贝技术并不意味着 1 次拷贝都没有，它只是说在用户空间到内核空间这个过程不需要拷贝</em></p><h4 id="sendfile" tabindex="-1"><a class="header-anchor" href="#sendfile"><span>sendfile</span></a></h4><p>顾名思义，sendfile 就是用来发送文件数据的</p><ul><li>程序发起 sendfile () 请求，消息从磁盘拷贝到内核空间中的内核缓冲区</li><li>消息从内核缓冲区通过 SG-DMA 直接拷贝到网卡<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809151001.png" alt="" loading="lazy"></li></ul><p><strong>整个过程总共有 1 次系统调用、2 次用户空间和内核空间的切换、2 次数据拷贝</strong></p><p><em>这里的零拷贝指的是 0 CPU 拷贝，sendfile 参与的场景下都不是 CPU 直接参与的拷贝，而是 DMA 控制器在干活，不耽误 CPU 跑程序</em></p><h3 id="所以说-kafka-的性能为什么比-rocketmq-好" tabindex="-1"><a class="header-anchor" href="#所以说-kafka-的性能为什么比-rocketmq-好"><span>所以说，Kafka 的性能为什么比 RocketMQ 好？</span></a></h3><p>这是因为 RocketMQ 使用的是 mmap 技术，而 Kafka 则选择了 sendfile<br> Kafka 以更少的拷贝次数以及系统内核切换次数获得了更好的性能</p><p>那么问题来了，RocketMQ 为什么不使用 sendfile 技术呢？<br> 难道是阿里的程序员连抄作业都不会？</p><p>这里我们需要看一下这两个函数的具体用法</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sendfile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> out_fd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">_fd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> off_t*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> offset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// num = sendfile(xxxx);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mmap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">addr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> prot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> flags</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> off_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> offset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// buf = mmap(xxxx);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>仔细分析就能发现<br> mmap 返回的是数据的具体内容，应用层能获取到消息内容并进行逻辑处理<br> 而 sendfile 则是成功发送了几个字节数，具体发送什么则是什么都不知道</p><p>RocketMQ 的某些功能特性，则需要获取到消息的具体内容，比如说将消费失败的消息重新投递到死信队列中<br> 而 Kafka 为了极致的性能，则选择放弃了这些特性</p><p><strong>没有一种架构是完美的，一种架构往往用于适配某些场景，很难做到既要又要</strong><br><strong>做架构，做到最后都是在做折中</strong></p>`,32)]))}const p=t(n,[["render",l],["__file","Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？.html.vue"]]),r=JSON.parse(`{"path":"/inbox/Kafka%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9FRocketMQ%20%E5%93%AA%E9%87%8C%E4%B8%8D%E5%A6%82%20Kafka%EF%BC%9F.html","title":"Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？","lang":"zh-CN","frontmatter":{"title":"Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？","tag":["消息队列","RocketMQ","Kafka"],"description":"Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？ - 小白 debug Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？ RocketMQ 在设计上参考了 Kafka，架构上更简单，功能更加丰富 看起来似乎是 RocketMQ 更加能打 但是 Kafka 一直没有被淘汰，说明 RocketMQ 必然有着不如 Kafk...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/inbox/Kafka%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9FRocketMQ%20%E5%93%AA%E9%87%8C%E4%B8%8D%E5%A6%82%20Kafka%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？"}],["meta",{"property":"og:description","content":"Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？ - 小白 debug Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？ RocketMQ 在设计上参考了 Kafka，架构上更简单，功能更加丰富 看起来似乎是 RocketMQ 更加能打 但是 Kafka 一直没有被淘汰，说明 RocketMQ 必然有着不如 Kafk..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809145531.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"消息队列"}],["meta",{"property":"article:tag","content":"RocketMQ"}],["meta",{"property":"article:tag","content":"Kafka"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809145531.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809150526.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240809151001.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"消息从消息队列的磁盘发送到消费者，过程是怎么样的？","slug":"消息从消息队列的磁盘发送到消费者-过程是怎么样的","link":"#消息从消息队列的磁盘发送到消费者-过程是怎么样的","children":[]},{"level":3,"title":"零拷贝技术","slug":"零拷贝技术","link":"#零拷贝技术","children":[{"level":4,"title":"mmap","slug":"mmap","link":"#mmap","children":[]},{"level":4,"title":"sendfile","slug":"sendfile","link":"#sendfile","children":[]}]},{"level":3,"title":"所以说，Kafka 的性能为什么比 RocketMQ 好？","slug":"所以说-kafka-的性能为什么比-rocketmq-好","link":"#所以说-kafka-的性能为什么比-rocketmq-好","children":[]}],"git":{"createdTime":1726242132000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":2,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":4.08,"words":1224},"filePathRelative":"inbox/Kafka 为什么这么快？RocketMQ 哪里不如 Kafka？.md","localizedDate":"2024年9月13日","autoDesc":true}`);export{p as comp,r as data};
