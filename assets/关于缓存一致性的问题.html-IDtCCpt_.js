import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as l,o as a}from"./app-BsnKshpw.js";const i={};function n(c,e){return a(),o("div",null,e[0]||(e[0]=[l('<h1 id="对于缓存的更新-目前主要有两种策略" tabindex="-1"><a class="header-anchor" href="#对于缓存的更新-目前主要有两种策略"><span>对于缓存的更新，目前主要有两种策略</span></a></h1><blockquote><p>缓存一致性问题往往发生在 <code>MySQL</code> 和 <code>Redis</code> 中<br> 在数据变更过程中，因为并发、系统故障等问题导致数据、缓存更新不一致</p></blockquote><h3 id="缓存更新策略" tabindex="-1"><a class="header-anchor" href="#缓存更新策略"><span>缓存更新策略</span></a></h3><p>对于缓存的更新，目前主要有两种策略</p><h4 id="超时剔除策略" tabindex="-1"><a class="header-anchor" href="#超时剔除策略"><span>超时剔除策略</span></a></h4><blockquote><p>适用于低一致性需求，很少发生变更的数据</p></blockquote><p>比方说将数据存在 <code>Redis</code> 中，并设置 <code>ttl</code><br> 读请求到来时发现数据过期后，重新去 <code>MySQL</code> 中查询并塞入缓存</p><h4 id="主动更新策略" tabindex="-1"><a class="header-anchor" href="#主动更新策略"><span>主动更新策略</span></a></h4><blockquote><p>适用于高一致性需求，常发生变更的数据<br> 超时剔除作为兜底</p></blockquote><p>数据发生变更后，主动发起对缓存的修改（更新或删除），可以通过异步线程、MQ 等方式</p><h3 id="操作类型" tabindex="-1"><a class="header-anchor" href="#操作类型"><span>操作类型</span></a></h3><h4 id="读操作-读缓存" tabindex="-1"><a class="header-anchor" href="#读操作-读缓存"><span>读操作（读缓存）</span></a></h4><ul><li><p>缓存命中，直接返回</p></li><li><p>缓存未命中，查库然后更新缓存</p></li></ul><h4 id="写操作-写缓存" tabindex="-1"><a class="header-anchor" href="#写操作-写缓存"><span>写操作（写缓存）</span></a></h4><ul><li><p>更新缓存？删除缓存？<br> 肯定是选择删除缓存！</p></li><li><p>先删除缓存，后更新数据库<br> 会存在并发场景下更新数据后依旧读取老数据的问题<br> 可以使用<strong>延迟双删</strong>策略<br><em>就是先删缓存，再更新数据库，然后等线程 sleep 一会再删一遍缓存</em></p></li><li><p>先更新数据库，后删除缓存<br> 这个会存在并发问题吗？会，但是概率太低，几乎不可能</p></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231218173904.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p><em>在这种情况下，才会出现读取到老数据的情况</em></p><p>但是一般情况下，写操作的请求时间往往会比读操作长，在 3-6 的间隙里做不完这么多事情</p><h3 id="为什么要删除缓存而不是更新缓存" tabindex="-1"><a class="header-anchor" href="#为什么要删除缓存而不是更新缓存"><span>为什么要删除缓存而不是更新缓存？</span></a></h3><ul><li><p>更新缓存会涉及到很多无用操作，很多时候 <code>Redis</code> 中存储的数据和 <code>MySQL</code> 中并不是一一对应的，而是通过处理后才写入到 <code>Redis</code> 中</p></li><li><p>缓存更新后并不会立马被访问到，这时 <code>Redis</code> 中就会存放这一份冗余的数据，会造成一定的浪费</p></li></ul><h3 id="先更新数据库-再删除缓存-一个操作成功-一个操作失败怎么办" tabindex="-1"><a class="header-anchor" href="#先更新数据库-再删除缓存-一个操作成功-一个操作失败怎么办"><span>先更新数据库，再删除缓存，一个操作成功，一个操作失败怎么办？</span></a></h3><p>这是由于系统故障导致的一致性问题</p><p><strong>解决方案</strong></p><ul><li><p>可以使用消息队列，更新数据库成功后往消息队列发消息，消费到消息后再删除缓存</p></li><li><p>订阅数据库变更日志 <code>binlog</code>（消息队列的进阶版，不用侵入到业务代码，比如 <code>canal</code>）</p></li></ul><p>两种方案的本质都是<strong>重试</strong></p>',25)]))}const d=t(i,[["render",n],["__file","关于缓存一致性的问题.html.vue"]]),s=JSON.parse(`{"path":"/project/Interview/%E7%BC%93%E5%AD%98/%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98.html","title":"对于缓存的更新，目前主要有两种策略 ","lang":"zh-CN","frontmatter":{"title":"对于缓存的更新，目前主要有两种策略 ","tag":["缓存","Cache"],"description":"对于缓存的更新，目前主要有两种策略 缓存一致性问题往往发生在 MySQL 和 Redis 中 在数据变更过程中，因为并发、系统故障等问题导致数据、缓存更新不一致 缓存更新策略 对于缓存的更新，目前主要有两种策略 超时剔除策略 适用于低一致性需求，很少发生变更的数据 比方说将数据存在 Redis 中，并设置 ttl 读请求到来时发现数据过期后，重新去 M...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/project/Interview/%E7%BC%93%E5%AD%98/%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"对于缓存的更新，目前主要有两种策略 "}],["meta",{"property":"og:description","content":"对于缓存的更新，目前主要有两种策略 缓存一致性问题往往发生在 MySQL 和 Redis 中 在数据变更过程中，因为并发、系统故障等问题导致数据、缓存更新不一致 缓存更新策略 对于缓存的更新，目前主要有两种策略 超时剔除策略 适用于低一致性需求，很少发生变更的数据 比方说将数据存在 Redis 中，并设置 ttl 读请求到来时发现数据过期后，重新去 M..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231218173904.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"缓存"}],["meta",{"property":"article:tag","content":"Cache"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"对于缓存的更新，目前主要有两种策略 \\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20231218173904.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"缓存更新策略","slug":"缓存更新策略","link":"#缓存更新策略","children":[{"level":4,"title":"超时剔除策略","slug":"超时剔除策略","link":"#超时剔除策略","children":[]},{"level":4,"title":"主动更新策略","slug":"主动更新策略","link":"#主动更新策略","children":[]}]},{"level":3,"title":"操作类型","slug":"操作类型","link":"#操作类型","children":[{"level":4,"title":"读操作（读缓存）","slug":"读操作-读缓存","link":"#读操作-读缓存","children":[]},{"level":4,"title":"写操作（写缓存）","slug":"写操作-写缓存","link":"#写操作-写缓存","children":[]}]},{"level":3,"title":"为什么要删除缓存而不是更新缓存？","slug":"为什么要删除缓存而不是更新缓存","link":"#为什么要删除缓存而不是更新缓存","children":[]},{"level":3,"title":"先更新数据库，再删除缓存，一个操作成功，一个操作失败怎么办？","slug":"先更新数据库-再删除缓存-一个操作成功-一个操作失败怎么办","link":"#先更新数据库-再删除缓存-一个操作成功-一个操作失败怎么办","children":[]}],"git":{"createdTime":1702895606000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":3,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":2.25,"words":675},"filePathRelative":"project/Interview/缓存/关于缓存一致性的问题.md","localizedDate":"2023年12月18日","autoDesc":true}`);export{d as comp,s as data};
