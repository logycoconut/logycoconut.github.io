import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as l,o as a}from"./app-DfvBXUGl.js";const i={};function c(r,e){return a(),o("div",null,e[0]||(e[0]=[l('<blockquote><ul><li>基于秒杀场景的Java高并发实现</li><li>对秒杀场景的方案设计</li><li>仓库地址: <a href="https://github.com/logycoconut/springboot-seckill" target="_blank" rel="noopener noreferrer">https://github.com/logycoconut/springboot-seckill</a></li></ul></blockquote><h2 id="技术体系" tabindex="-1"><a class="header-anchor" href="#技术体系"><span>技术体系</span></a></h2><ul><li><p>前端: <code>Bootstrap</code> + <code>jQuery</code></p></li><li><p>后端: <code>SpringBoot2</code> + <code>MyBatisPlus</code> + <code>MySQL</code></p></li><li><p>中间件技术: <code>Redis</code> + <code>RabbitMQ</code> + <code>JWT</code></p></li></ul><h2 id="秒杀场景以及解决方案" tabindex="-1"><a class="header-anchor" href="#秒杀场景以及解决方案"><span>秒杀场景以及解决方案</span></a></h2><h3 id="高并发" tabindex="-1"><a class="header-anchor" href="#高并发"><span>高并发</span></a></h3><blockquote><p>在传统WEB应用中, 每次请求都是对数据库的一次访问; 但是在秒杀场景下, 流量会在瞬间达到上万以上, 这么多请求要是都流向数据库, 数据库立马就会挂掉 秒杀活动被迫中断</p></blockquote><p>所以我们应该尽量将请求拦截在上游, 对请求进行限流</p><p><strong>前端限流 :</strong></p><ul><li>秒杀前将秒杀按钮置灰 ( 即不可点击的状态 )</li><li>秒杀时限制点击频率, 例如每秒最多点击一次</li></ul><p><strong>后端限流 :</strong></p><ul><li>令牌桶算法限流, 例如 <code>Guava</code> 的 <code>RateLimiter</code>, 就是以固定的频率向桶中放入令牌, 每次秒杀前都从桶中获取令牌, 取到令牌后才能进入下一步, 否则返回错误代码</li></ul><p><strong>库存预热</strong></p><ul><li>在服务启动时将秒杀相关信息都加载到<code>Redis</code>中, 商品库存的删减都在<code>Redis</code>中进行</li></ul><p><strong>消息队列</strong></p><ul><li>用户只关心当时是否成功秒杀, 对于后台数据库真实库存的变化以及订单创建快慢并不敏感</li><li>运行消息队列缓冲过量流量, 将同步操作转换成异步推送, 在队列的另一端平滑地将消息推送出去, 平稳的对数据库进行访问</li></ul><p><strong>资源静态化</strong></p><ul><li>不再需要服务器渲染好页面然后传到浏览器, 而是由静态页面来请求数据</li></ul><h3 id="超卖" tabindex="-1"><a class="header-anchor" href="#超卖"><span>超卖</span></a></h3><ul><li>对商品库存加乐观锁</li></ul><h3 id="链接暴露" tabindex="-1"><a class="header-anchor" href="#链接暴露"><span>链接暴露</span></a></h3><ul><li>秒杀链接的提前暴露可能会导致有人绕过业务直接请求接口,为了防止这种情况发生, 我们可以采取URL动态化的方式</li><li><strong>具体实现思路 :</strong> 在秒杀开始之前, 先获取秒杀地址, 再根据秒杀地址进行秒杀</li></ul><h3 id="恶意请求" tabindex="-1"><a class="header-anchor" href="#恶意请求"><span>恶意请求</span></a></h3><ul><li>采取验证码的方式防止大量重复请求, 同时也可以分担流量压力</li></ul><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><ul><li><p>本项目是对 <a href="https://github.com/zaiyunduan123/springboot-sckill" target="_blank" rel="noopener noreferrer">zaiyunduan123/springboot-seckill</a> 的二次开发, 在项目初期给了我很大的启发</p></li><li><p>在后期寻求再次优化的时候, 敖丙的文章也让我对秒杀系统的整体架构有了更清楚的认知, <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453145142&amp;idx=1&amp;sn=3a25d7caf7135a64112e4f9ac2224a9e&amp;chksm=8cfd24b5bb8aada34295666b6b4eace58efa44cd2a9f07c06ca2a61242583e83cea3d1b98143&amp;scene=158#rd" target="_blank" rel="noopener noreferrer">敖丙带你设计【秒杀系统】</a></p></li></ul>',25)]))}const p=t(i,[["render",c],["__file","200827_设计一个秒杀系统.html.vue"]]),d=JSON.parse(`{"path":"/archive/blog/2020/200827_%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html","title":"设计一个秒杀系统","lang":"zh-CN","frontmatter":{"title":"设计一个秒杀系统","date":"2020-08-26T16:11:56.000Z","draft":false,"category":["关于技术"],"tag":["SpringBoot","高并发"],"description":"基于秒杀场景的Java高并发实现 对秒杀场景的方案设计 仓库地址: https://github.com/logycoconut/springboot-seckill 技术体系 前端: Bootstrap + jQuery 后端: SpringBoot2 + MyBatisPlus + MySQL 中间件技术: Redis + RabbitMQ + J...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/archive/blog/2020/200827_%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"设计一个秒杀系统"}],["meta",{"property":"og:description","content":"基于秒杀场景的Java高并发实现 对秒杀场景的方案设计 仓库地址: https://github.com/logycoconut/springboot-seckill 技术体系 前端: Bootstrap + jQuery 后端: SpringBoot2 + MyBatisPlus + MySQL 中间件技术: Redis + RabbitMQ + J..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"SpringBoot"}],["meta",{"property":"article:tag","content":"高并发"}],["meta",{"property":"article:published_time","content":"2020-08-26T16:11:56.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计一个秒杀系统\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-08-26T16:11:56.000Z\\",\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"技术体系","slug":"技术体系","link":"#技术体系","children":[]},{"level":2,"title":"秒杀场景以及解决方案","slug":"秒杀场景以及解决方案","link":"#秒杀场景以及解决方案","children":[{"level":3,"title":"高并发","slug":"高并发","link":"#高并发","children":[]},{"level":3,"title":"超卖","slug":"超卖","link":"#超卖","children":[]},{"level":3,"title":"链接暴露","slug":"链接暴露","link":"#链接暴露","children":[]},{"level":3,"title":"恶意请求","slug":"恶意请求","link":"#恶意请求","children":[]}]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]}],"git":{"createdTime":1667915485000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"1425795337@qq.com","commits":1,"url":"https://github.com/logycoconut"},{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":5,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":2.26,"words":679},"filePathRelative":"archive/blog/2020/200827_设计一个秒杀系统.md","localizedDate":"2020年8月26日","autoDesc":true}`);export{p as comp,d as data};
