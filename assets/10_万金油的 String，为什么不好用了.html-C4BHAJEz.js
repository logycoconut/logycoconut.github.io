import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as s,o as n}from"./app-mbwvGqXF.js";const a={};function p(l,i){return n(),t("div",null,i[0]||(i[0]=[s(`<p>从这篇开始就要进入&quot;实战篇&quot;了<br> 接下来，我们会用 5 节课的时间学习“数据结构”<br> 我会介绍节省内存开销以及保存和统计海量数据的数据类型及其底层数据结构，还会围绕典型的应用场景（例如地址位置查询、时间序列数据库读写和消息队列存取），跟你分享使用 Redis 的数据类型和 module 扩展功能来满足需求的具体方案</p><p>今天，先来了解下 String 类型的内存空间消耗问题，以及选择节省内存开销的数据类型的解决方案</p><p>先分享一个曾经遇到的需求</p><p>当时需要开发一个图片存储系统，要求这个系统能快速地记录图片 ID 和图片在存储系统中保存的 ID（可以叫做图片存储对象 ID）<br> 同时，还要能够根据图片 ID 快速查找到图片存储 ID</p><p>因为图片数量巨大，所以我们就用 10 位数来表示图片 ID 和图片存储对象 ID<br> 例如，图片 ID 为 1101000051，它在存储系统中对应的 ID 号是 3301000051</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>photo_id: 1101000051 </span></span>
<span class="line"><span>photo_obj_id: 3301000051</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，图片 ID 和图片存储 ID 正好一一对应，是典型的&quot;键-单值&quot;模式<br> 所谓的单值，就是指键值对中的值就是一个值，而不是一个集合，这与 String 类型提供的&quot;一个键对应一个值的数据&quot;的保存形式刚好契合</p><p>而且，String 类型可以保存二进制字节流，就像万金油一样，只要把数据转换成二进制字节数组，就可以保存了</p><p>所以，我们的第一个方案就是用 String 保存数据<br> 我们把图片 ID 和图片存储对象 ID 分别作为键值对的 key 和 value 来保存<br> 其中，图片存储对象 ID 用了 String 类型</p><p>刚开始，我们保存了 1 亿张图片，大约用了 6.4GB 的内存<br> 但是随着图片数据量的不断增加，我们的 Redis 内存使用量也在增加，结果就遇到了大内存 Redis 实例因为生成 RDB 而响应变慢的问题<br> 很显然，String 类型并不是一个好的选择，我们还需要进一步寻找能节省内存开销的数据类型方案</p><p>String 类型并不是适用于所有场合的，它有一个明显的短板，就是它保存数据时所消耗的内存空间较多</p><p>同时，作者还仔细研究了集合类型的数据结构<br> 于是发现，集合类型有非常节省内存空间的底层实现结构，但是，集合类型保存的数据模式，是一个键对应一系列值，并不适合直接保存单值的键值对<br> 所以需要采用二级编码的方法，实现用集合类型保存单值键值对，Redis 的内存空间消耗明显下降了</p><h3 id="为什么-string-类型内存开销大" tabindex="-1"><a class="header-anchor" href="#为什么-string-类型内存开销大"><span>为什么 String 类型内存开销大？</span></a></h3><p>在刚才的案例中，我们保存了 1 亿张图片的信息，用了约 6.4GB 的内存，一个图片 ID 和图片存储对象 ID 的记录平均用了 64 字节</p><p>但问题是，一组图片 ID 及其存储对象 ID 的记录，实际只需要 16 字节就可以了</p><p>我们来分析一下<br> 图片 ID 和图片存储对象 ID 都是 10 位数，我们可以用两个 8 字节的 Long 类型表示这两个 ID<br> 因为 8 字节的 Long 类型最大可以表示 2 的 64 次方的数值，所以肯定可以表示 10 位数<br> 但是为什么 String 类型却用了 64 字节呢？</p><p>其实，除了记录实际数据，String 类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作元数据<br> 当实际保存的数据较小时，元数据的空间开销就显得比较大了，有点&quot;喧宾夺主&quot;的意思</p><p>那么，String 类型具体是怎么保存数据的呢</p><p>当你保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 Long 类型整数<br> 这种保存方式通常也叫作 int 编码方式</p><p>但是，当你保存的数据中包含字符时，String 类型就会用**简单动态字符串结构体（Simple Dynamic String，SDS）**来保存，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305145415.png" alt="" loading="lazy"></p><ul><li>buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个<code>\\0</code>，这就会额外占用一个字节的开销</li><li>len：占 4 个字节，表示 buf 的已用长度</li><li>alloc：占 4 个字节，表示 buf 的实际分配长度，一般大于 len</li></ul><p>可以看到，在 SDS 中，buf 保存实际数据，而 len 和 alloc 本身其实是 SDS 结构体的额外开销</p><p>另外，对于 String 类型来说，除了 SDS 的额外开销，还有一个来自于 RedisObject 结构体的开销</p><p>因为 Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等）<br> 所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据</p><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在，例如指向 String 类型的 SDS 结构所在的内存地址，可以看下如下的示意图</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305152756.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为了节省内存空间，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计</p><p>一方面，当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销</p><p>另一方面，当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片<br><em>这种布局方式也被称为 embstr 编码方式</em></p><p>当然，当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构<br><em>这种布局方式被称为 raw 编码模式</em></p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305153313.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>好了，知道了 RedisObject 所包含的额外元数据开销<br> 现在我们可以计算 String 类型的内存使用量了</p><p>因为 10 位数的图片 ID 和图片存储对象是 Long 类型整数，所以可以直接用 int 编码的 RedisObject 保存<br> 每个 int 编码的 RedisObject 元数据部分占 8 字节，指针部分被直接赋值为 8 字节的整数了<br> 此时，每个 ID 会使用 16 字节，加起来一共是 32 字节<br> 但是，另外的 32 字节去哪儿了呢？</p><p>在之前的内容中说过，Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对<br> dictEntry 结构中有 3 个 8 字节的指针，分别指向 key、value 以及下一个 dictEntry，3 个指针共 24 字节<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305153914.png" alt="" loading="lazy"></p><p>但是，这 3 个指针只有 24 字节，为什么会占用了 32 字节呢？<br> 这就要提到 Redis 使用的内存分配库 jemalloc 了</p><p>jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次方作为分配的空间，这样可以减少频繁分配的次数</p><p>举个例子，如果你要申请 6 字节的空间，jemalloc 实际会分配 8 字节空间<br> 如果要申请 24 字节空间，jemalloc 则会分配 32 字节<br> 所以，在我们刚刚说的场景里，dictEntry 结构就占用了 32 字节</p><p>到这儿，你应该能理解，为什么用 String 类型保存图片 ID 和图片存储对象 ID 时需要用 64 个字节了</p><p>一亿条的图片 ID 记录需要 6.4GB 的空间，其中有 4.8GB 的内存空间都用来保存元数据了，额外的内存空间空小很大<br> 那么有没有更加节省内存的方法呢？</p><h3 id="用什么数据结构可以节省内存" tabindex="-1"><a class="header-anchor" href="#用什么数据结构可以节省内存"><span>用什么数据结构可以节省内存？</span></a></h3><p>Redis 有一种底层数据结构，叫压缩列表（ziplist），这是一种非常节省内存的结构</p><p>我们先回顾下压缩列表的构成<br> 表头有三个字段 zlbytes、zltail、和 zllen，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数<br> 压缩列表表尾还有一个 zlend，表示列表结束<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305164709.png" alt="" loading="lazy"></p><p>压缩列表之所以能节省内存，就在于它是用一系列连续的 Entry 保存数据<br> 每个 entry 的元数据包括下面几部分</p><ul><li><code>prev_len</code>: 表示前一个 entry 的长度<br> prev_len 有两种取值情况：1 字节或 5 字节<br> 取值 1 字节时，表示上一个 entry 的长度小于 254 字节，虽然 1 字节的值能表示的数值范围是 0-255，但是压缩列表中的 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了<br> 所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则为 5 字节</li><li><code>len</code>：表示自身长度，4 字节</li><li><code>encoding</code>：表示编码字节，1 字节</li><li><code>content</code>：保存实际数据</li></ul><p>这些 entry 会挨个放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间</p><p>我们以保存图片存储对象 ID 为例，来分析一下压缩列表是如何节省内存的</p><p>每个 entry 保存一个图片存储对象 ID（8 字节），此时，每个 entry 的 <code>prev_len</code> 只需要 1 个字节就行，因为每个 entry 的前一个 entry 长度都只有 8 字节，小于 254 字节<br> 这样一来，一个图片的存储对象 ID 所占用的内存大小是 14 字节（1+4+1+8），实际分配 16 字节</p><p>Redis 基于压缩列表实现了 List、Hash、Sorted Set 这样的集合类型<br> 这样做的最大好处就是节省了 dictEntry 的开销<br> 当你用 String 类型时，一个键值对就有一个 dicEntry，要用 32 字节空间<br> 但是采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存</p><p>但是，在用集合类型保存键值对时，一个键对应了一个集合的数据，但是在我们的场景中，一个图片 ID 只对应一个图片的存储对象 ID，我们该怎么用集合类型呢？</p><h3 id="如何用集合类型保存单值的键值对" tabindex="-1"><a class="header-anchor" href="#如何用集合类型保存单值的键值对"><span>如何用集合类型保存单值的键值对</span></a></h3><p>在保存单值的键值对时，可以采用基于 Hash 的二级编码方式<br> 这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value，这样一来，我们就可以把单值数据保存到 Hash 集合中了</p><p>以图片 ID 1101000060 和图片存储对象 ID 3302000080 为例，我们可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value</p><p>按照这种设计，我在 Redis 中插入了一组图片 ID 及其存储对象记录，并且用 info 命令查看了内存开销<br> 我发现，增加一条记录后，内存占用只增加了 16 字节，如下所示</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">info</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> memory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Memory </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">used_memory:1039120</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">hset</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1101000</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 060</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3302000080</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">127.0.0.1:6379</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">info</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> memory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Memory </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">used_memory:1039136</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而使用 String 类型时，每个记录需要消耗 64 字节，这种方式却只用了 16 字节，所使用的内存空间是原来的 1/4，满足了我们节省空间的需求</p><p>不过，可能也会有疑惑<br> &quot;二级编码一定要把图片 ID 的前 7 位作为 Hash 类型的键，把最后 3 位作为 Hash 类型值中的 key 吗&quot;<br><strong>其实，二级编码方法中采用的 ID 长度是有讲究的</strong></p><p>之前说过，Redis Hash 类型的两种底层实现结构，分别是压缩列表和哈希表</p><p>那么，Hash 类型底层结构什么时候使用压缩列表，什么时候使用哈希表呢？<br> 其实，Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了</p><ul><li><code>hash-max-ziplist-entries</code>: 表示用压缩列表保存时哈希集合中的最大元素个数</li><li><code>hash-max-ziplist-value</code>：表示用压缩列表保存时哈希集合中单个元素的最大长度</li></ul><p>如果我们往 Hash 集合中写入的元素个数超过了 <code>hash-max-ziplist-entries</code>，或者写入的单个元素大小超过了 <code>hash-max-ziplist-value</code>，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表</p><p>一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表来保存，而不会再转回压缩列表了<br> 在节省内存空间方面，哈希表就没有压缩列表那么高效了</p><p><strong>为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合的元素个数</strong><br> 所以，在刚才的二级编码中，我们只用图片 ID 最后 3 位作为 Hash 集合的 key，也就保证了 Hash 集合的元素个数不超过 1000<br> 同时我们把 <code>hash-max-ziplist-entries</code> 设置为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省空间了</p>`,62)]))}const d=e(a,[["render",p],["__file","10_万金油的 String，为什么不好用了.html.vue"]]),h=JSON.parse(`{"path":"/project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/10_%E4%B8%87%E9%87%91%E6%B2%B9%E7%9A%84%20String%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%A5%BD%E7%94%A8%E4%BA%86.html","title":"10_万金油的 String，为什么不好用了","lang":"zh-CN","frontmatter":{"title":"10_万金油的 String，为什么不好用了","tag":["Redis"],"category":["Redis 核心技术与实战"],"description":"从这篇开始就要进入\\"实战篇\\"了 接下来，我们会用 5 节课的时间学习“数据结构” 我会介绍节省内存开销以及保存和统计海量数据的数据类型及其底层数据结构，还会围绕典型的应用场景（例如地址位置查询、时间序列数据库读写和消息队列存取），跟你分享使用 Redis 的数据类型和 module 扩展功能来满足需求的具体方案 今天，先来了解下 String 类型的内...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/project/Redis/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%20-%20%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/10_%E4%B8%87%E9%87%91%E6%B2%B9%E7%9A%84%20String%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%A5%BD%E7%94%A8%E4%BA%86.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"10_万金油的 String，为什么不好用了"}],["meta",{"property":"og:description","content":"从这篇开始就要进入\\"实战篇\\"了 接下来，我们会用 5 节课的时间学习“数据结构” 我会介绍节省内存开销以及保存和统计海量数据的数据类型及其底层数据结构，还会围绕典型的应用场景（例如地址位置查询、时间序列数据库读写和消息队列存取），跟你分享使用 Redis 的数据类型和 module 扩展功能来满足需求的具体方案 今天，先来了解下 String 类型的内..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305145415.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"10_万金油的 String，为什么不好用了\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305145415.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305152756.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305153313.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305153914.png\\",\\"https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240305164709.png\\"],\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":3,"title":"为什么 String 类型内存开销大？","slug":"为什么-string-类型内存开销大","link":"#为什么-string-类型内存开销大","children":[]},{"level":3,"title":"用什么数据结构可以节省内存？","slug":"用什么数据结构可以节省内存","link":"#用什么数据结构可以节省内存","children":[]},{"level":3,"title":"如何用集合类型保存单值的键值对","slug":"如何用集合类型保存单值的键值对","link":"#如何用集合类型保存单值的键值对","children":[]}],"git":{"createdTime":1709219421000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":4,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":12.11,"words":3633},"filePathRelative":"project/Redis/Redis 核心技术与实战 - 极客时间/10_万金油的 String，为什么不好用了.md","localizedDate":"2024年2月29日","autoDesc":true}`);export{d as comp,h as data};
