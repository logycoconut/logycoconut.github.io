import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as t,f as o}from"./app-0845c340.js";const a={},p=o('<p>之前我们学习了主从库集群模式<br> 在这个模式下，如果从库发生故障了，客户端就可以继续向主库或其他从库发送请求，进行相关的操作，但是如果主库发生故障了，那就直接会影响到从库的同步，因为从库没有相应的主库可以进行数据复制操作了</p><p>而且，如果客户端发送的都是读操作请求，那还可以由从库继续提供服务，这在纯读的业务场景下还能被接收<br> 但是一旦有写操作请求了，按照主从库模式下的读写分离要求，需要由主库来完成写操作<br> 此时，也没有实例可以来服务客户端的写操作请求了<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240229181449.png" alt="主库故障后从库无法服务写操作" loading="lazy"></p><p>无论是写服务中断，还是从库无法进行数据同步，都是不能接受的<br> 所以，如果主库挂了，我们就需要运行一个新的主库，比如说把一个从库切换为主库，把它当作主库<br> 这就设计三个问题</p><ul><li>主库真的挂了吗？</li><li>该选择哪个从库作为主库？</li><li>怎么把新主库的相关信息通知给从库和客户端呢？</li></ul><p>这就要提到哨兵模式了<br> 在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制下故障转移的这三个问题</p><h3 id="哨兵机制的基本流程" tabindex="-1"><a class="header-anchor" href="#哨兵机制的基本流程" aria-hidden="true">#</a> 哨兵机制的基本流程</h3><p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行<br> 哨兵主要负责的就是三个任务：监控、选主、通知</p><h4 id="监控" tabindex="-1"><a class="header-anchor" href="#监控" aria-hidden="true">#</a> 监控</h4><p>监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行<br> 如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就把它标记为&quot;下线状态&quot;<br> 同样，如果主库没有在规定时间内响应哨兵的 PING 命令，哨兵就会判断主库下线，然后开始<strong>自动切换主库</strong>的流程</p><h4 id="选主" tabindex="-1"><a class="header-anchor" href="#选主" aria-hidden="true">#</a> 选主</h4><p>主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库，这一步完成后，现在的集群里就有了新主库</p><h4 id="通知" tabindex="-1"><a class="header-anchor" href="#通知" aria-hidden="true">#</a> 通知</h4><p>在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让他们执行 replicaof 命令，和新主库建立连接，并进行数据复制<br> 同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240229181905.png" alt="哨兵机制的三项任务与目标" tabindex="0" loading="lazy"><figcaption>哨兵机制的三项任务与目标</figcaption></figure><p>在这三个任务中，通知任务相对来说比较简单，哨兵只需要把新主库信息发给从库和客户端，让他们和新主库建立连接就行，并不涉及决策的逻辑</p><p>但是，在监控和选主两个任务中，哨兵需要做出两个决策</p><ul><li>在监控任务中，哨兵需要判断主库是否处于下线状态</li><li>在选主任务中，哨兵也要决定选择哪个从库实例作为主库</li></ul><h3 id="主观下线和客观下线" tabindex="-1"><a class="header-anchor" href="#主观下线和客观下线" aria-hidden="true">#</a> 主观下线和客观下线</h3><p>哨兵对主库的下线判断有&quot;主观下线&quot;和&quot;客观下线&quot;两种</p><p>先来解释下什么是&quot;主观下线&quot;</p><p>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态<br> 如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会把它标记为&quot;主观下线&quot;</p><p>如果检测的是从库，那么，哨兵简单地把它标记为&quot;主观下线&quot;就行了，因为从库的下线影响一般不太大，集群的对外服务不会间断</p><p>但是，如果检测的是主库，那么，哨兵还不能简单地把它标记为&quot;主观下线&quot;，开启主从切换<br> 因为很有可能存在这么一个情况：那就是哨兵误判了，其实主库并没有故障<br> 可是，一旦启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销</p><p>为了避免这些不必要的开销，我们要特别注意误判的情况</p><p>首先，我们要知道什么是误判<br> 很简单，就是主库实际并没有下线，但是哨兵误以为它下线了<br> 误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下</p><p>一旦哨兵判断主库下线了，就会开始选择新主库，并让从库和新主库进行数据同步，这个过程本身就会有开销<br> 例如，哨兵要花时间选出新主库，从库也需要花时间和新主库同步<br> 而在误判的情况下，主库本身根本就不需要进行切换的，所以这个过程的开销是没有价值的<br> 正因为这样，我们需要判断是否有误判，以及减少误判</p><p>那怎么减少误判呢？在日常生活中，当我们要对一些重要的事情做判断的时候，经常会和家人或朋友一起商量一下，然后再做决定</p><p>哨兵机制也是类似的，<strong>它通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群</strong><br> 引入多个哨兵实例一起判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况<br> 同时，多个哨兵的网络同时不稳定的概率较小，由他们一起做决策，误判率也能降低</p><p>在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经&quot;主观下线&quot;了，主库才会被标记成&quot;客观下线&quot;，这个叫法也是表明主库下线成为一个客观事实了<br> 这个判断原则就是：少数服从多数<br> 同时，这会进一步触发哨兵开始主从切换流程</p><figure><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240229202608.png" alt="客观下线的判断" tabindex="0" loading="lazy"><figcaption>客观下线的判断</figcaption></figure><p>根据上图，&quot;客观下线&quot;的标准就是，当有 N 个哨兵实例时，最好要有 <code>N/2 + 1</code> 个实例判断主库为&quot;主观下线&quot;，才能最终判定主库为&quot;客观下线&quot;<br> 这样一来，就可以减少误判的概率，也能避免误判带来的无畏的主从库切换<br><em>有多少个实例做出&quot;主观下线&quot;的判断才可以，可以由 Redis 管理员自行设定</em></p><h3 id="如何选定新主库" tabindex="-1"><a class="header-anchor" href="#如何选定新主库" aria-hidden="true">#</a> 如何选定新主库？</h3><p>一般来说，哨兵选择新主库的过程称为&quot;筛选+打分&quot;<br> 在多个从库中，先按照<strong>一定的筛选条件</strong>，把不符合条件的从库去掉<br> 然后再按照<strong>一定的规则</strong>，给剩下的从库逐个打分，将得分最高的从库选为新主库</p><p>首先我们来看筛选的条件</p><p>一般情况下，我们肯定要先保证所选的从库仍然在线运行<br> 不过，在选主时从库正常在线，这只能表示从库的现状良好，并不代表它就是最适合做主库的</p><p>设想一下，如果在选主时，一个从库正常运行，我们把它选为新主库开始使用<br> 可是，很快它的网络除了故障，此时，我们就得重新选主了<br> 这显然不是我们期望的结果</p><p>所以，在选主时，<strong>除了要检查从库的当前在线状态，还要判断它之前的网络连接状态</strong><br> 如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了</p><p>具体怎么判断呢？<br> 你使用配置项 down-after-milliseconds * 10<br> 其中，down-after-milliseconds 是我们设定主从库断连的最大连接超时时间<br> 如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了<br> 如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库</p><p>好了，这样我们就过滤掉了不适合做主库的从库，完成了筛选工作</p><p>接下来就要给剩余的从库打分了<br> 我们可以按照三个规则依次进行三轮打分，这三个规则分别是<strong>从库优先级、从库复制进度以及从库 ID 号</strong><br> 只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束<br> 如果没有出现得分最高的从库，那么就继续进行下一轮</p><h4 id="第一轮-优先级最高的从库得分高" tabindex="-1"><a class="header-anchor" href="#第一轮-优先级最高的从库得分高" aria-hidden="true">#</a> 第一轮：优先级最高的从库得分高</h4><p>用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级<br> 比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级<br> 在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库<br> 如果从库的优先级一样，那么哨兵开始第二轮打分</p><h4 id="第二轮-和旧主库同步程度最接近的从库得分高" tabindex="-1"><a class="header-anchor" href="#第二轮-和旧主库同步程度最接近的从库得分高" aria-hidden="true">#</a> 第二轮：和旧主库同步程度最接近的从库得分高</h4><p>这个规则的依据是，如果选择和旧主库同步最接近的哪个从库作为主库，那么这个新主库上就有最新的数据</p><p>如何判断从库和旧主库间的同步进度呢？</p><p>之前介绍过，主从库同步时有个命令传播的过程<br> 在这个过程中，主库会用 <code>master_repl_offset</code> 记录当前的最新写操作在 <code>repl_backlog_buffer</code> 中的位置，而从库会用 <code>slave_repl_offset</code> 这个值记录当前的复制进度</p><p>此时，我们想要找的从库，它的 <code>slave_repl_offset</code> 需要最接近 <code>master_repl_offset</code>，那么它的得分就最高，可以作为新主库<br><img src="https://cdn.jsdelivr.net/gh/logycoconut/pic-repo/tech/20240229215611.png" alt="基于复制进度的新主库选主原则" loading="lazy"></p><p>上图中，从库 2 就应该被选为新主库</p><h4 id="第三轮-id-号小的从库得分高" tabindex="-1"><a class="header-anchor" href="#第三轮-id-号小的从库得分高" aria-hidden="true">#</a> 第三轮：ID 号小的从库得分高</h4><p>每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号<br> 目前，Redis 在选主库时，有一个默认的设定：<strong>在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库</strong></p>',50),i=[p];function d(n,c){return e(),t("div",null,i)}const l=r(a,[["render",d],["__file","07_哨兵模式：主库挂了，如何不间断服务？.html.vue"]]);export{l as default};
