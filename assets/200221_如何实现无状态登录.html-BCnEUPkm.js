import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as a,o as i}from"./app-DfvBXUGl.js";const l={};function t(p,n){return i(),e("div",null,n[0]||(n[0]=[a(`<h2 id="有状态和无状态" tabindex="-1"><a class="header-anchor" href="#有状态和无状态"><span>有状态和无状态</span></a></h2><h3 id="什么是有状态" tabindex="-1"><a class="header-anchor" href="#什么是有状态"><span>什么是有状态</span></a></h3><p>服务器需要记录每次会话的用户信息, 从而识别用户信息, 根据用户身份对请求处理, 例如说tomcat的session</p><p>用户登陆后, 服务器将用户信息保存在session中, 然后返回用户一个cookie, cookie中记录了session的id</p><p>在用户下次请求时, 我们就可以根据session的id找到对应的用户信息, 这样就实现了用户的登录验证</p><p>如果存在很多用户, 那么服务器就需要保存大量session数据, 给服务器带来很大的压力</p><h3 id="什么是无状态" tabindex="-1"><a class="header-anchor" href="#什么是无状态"><span>什么是无状态</span></a></h3><p>有状态服务依赖于服务器, 多次请求必须请求同一台服务器, 这不符合微服务集群的思想</p><p>REST风格的一个重要规范即是服务的无状态性</p><p>服务器不需要保存任何客户端用户信息</p><p>客户端的每次请求必须都具备自描述信息, 这样服务器才能通过这些信息识别请求所属</p><h2 id="实现无状态" tabindex="-1"><a class="header-anchor" href="#实现无状态"><span>实现无状态</span></a></h2><ul><li>用户登录</li><li>服务器返回token信息, 放在cookie中</li><li>之后的每次请求都携带token信息</li><li>服务器解析token判断请求是否有效 ( 是否过期? 是否被篡改? )</li></ul><p>可以看出, 在无状态登录过程中, token至关重要</p><p>所以我们需要学习token的生成以及加密</p><h3 id="jwt" tabindex="-1"><a class="header-anchor" href="#jwt"><span>JWT</span></a></h3><p>JWT的全称是Json Web Token, 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权</p><p><em><a href="https://jwt.io/" target="_blank" rel="noopener noreferrer">官网</a>可以在线调试JWT</em></p><ul><li>包含三部分数据, <code>Header</code>, <code>Payload</code>, <code>Signature</code></li><li><code>Header:</code> 描述该JWT最基本的信息, 例如类型以及签名所用的算法</li><li><code>Payload:</code> 存放有效信息的地方, 采用base64编码, 不要放敏感信息</li><li><code>Signature:</code> 前两部分组合, 然后通过声明的加密方式加盐生成</li></ul><h3 id="rsa" tabindex="-1"><a class="header-anchor" href="#rsa"><span>RSA</span></a></h3><p>RAS, 是一种非对称加密算法</p><ul><li>根据一串密文同时生成私钥和公钥</li><li>私钥隐秘保存, 公钥下发给信任的客户端</li><li>私钥加密, 私钥和公钥可以解密</li><li>公钥加密, 私钥可以解密</li></ul><h3 id="结合rsa的鉴权" tabindex="-1"><a class="header-anchor" href="#结合rsa的鉴权"><span>结合RSA的鉴权</span></a></h3><ul><li>客户端发送登录请求, 请求通过网关发送给授权中心</li><li>授权中心验证用户名密码之后下发私钥加密后的token</li><li>之后客户端的每次请求都携带着token</li><li>被信任的微服务中都存放着公钥, 通过公钥解析token, 对请求进行处理</li></ul><h3 id="java实现" tabindex="-1"><a class="header-anchor" href="#java实现"><span>Java实现</span></a></h3><ul><li>引入maven</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;0.9.0&lt;/version&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>编写工具类</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>
<span class="line"><span> * 假设token中存放着用户id以及用户名</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>public class JwtUtils {</span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 私钥加密token</span></span>
<span class="line"><span>     * @param userInfo  载荷中的数据</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public static String generateToken(UserInfo userInfo, PrivateKey privateKey, int expireMinutes) throws Exception {</span></span>
<span class="line"><span>        return Jwts.builder()</span></span>
<span class="line"><span>                .claim(&quot;id&quot;, userInfo.getId())</span></span>
<span class="line"><span>                .claim(&quot;username&quot;, userInfo.getUsername())</span></span>
<span class="line"><span>                .setExpiration(DateTime.now().plusMinutes(expireMinutes).toDate())</span></span>
<span class="line"><span>                .signWith(SignatureAlgorithm.RS256, privateKey)</span></span>
<span class="line"><span>                .compact();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 公钥解析token</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    private static Jws&lt;Claims&gt; parserToken(String token, PublicKey publicKey) {</span></span>
<span class="line"><span>        return Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 获取token中的用户信息</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    public static UserInfo getInfoFromToken(String token, PublicKey publicKey) throws Exception {</span></span>
<span class="line"><span>        Jws&lt;Claims&gt; claimsJws = parserToken(token, publicKey);</span></span>
<span class="line"><span>        Claims body = claimsJws.getBody();</span></span>
<span class="line"><span>        return new UserInfo(</span></span>
<span class="line"><span>                ObjectUtils.toLong(body.get(&quot;id&quot;)),</span></span>
<span class="line"><span>                ObjectUtils.toString(body.get(&quot;username&quot;))</span></span>
<span class="line"><span>        );</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,29)]))}const r=s(l,[["render",t],["__file","200221_如何实现无状态登录.html.vue"]]),d=JSON.parse(`{"path":"/archive/blog/2020/200221_%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95.html","title":"如何实现无状态登录","lang":"zh-CN","frontmatter":{"title":"如何实现无状态登录","date":"2020-02-21T14:18:22.000Z","draft":false,"category":["关于技术"],"tag":["login"],"description":"有状态和无状态 什么是有状态 服务器需要记录每次会话的用户信息, 从而识别用户信息, 根据用户身份对请求处理, 例如说tomcat的session 用户登陆后, 服务器将用户信息保存在session中, 然后返回用户一个cookie, cookie中记录了session的id 在用户下次请求时, 我们就可以根据session的id找到对应的用户信息, ...","head":[["meta",{"property":"og:url","content":"https://logycoconut.github.io/archive/blog/2020/200221_%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"如何实现无状态登录"}],["meta",{"property":"og:description","content":"有状态和无状态 什么是有状态 服务器需要记录每次会话的用户信息, 从而识别用户信息, 根据用户身份对请求处理, 例如说tomcat的session 用户登陆后, 服务器将用户信息保存在session中, 然后返回用户一个cookie, cookie中记录了session的id 在用户下次请求时, 我们就可以根据session的id找到对应的用户信息, ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"login"}],["meta",{"property":"article:published_time","content":"2020-02-21T14:18:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何实现无状态登录\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-02-21T14:18:22.000Z\\",\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"有状态和无状态","slug":"有状态和无状态","link":"#有状态和无状态","children":[{"level":3,"title":"什么是有状态","slug":"什么是有状态","link":"#什么是有状态","children":[]},{"level":3,"title":"什么是无状态","slug":"什么是无状态","link":"#什么是无状态","children":[]}]},{"level":2,"title":"实现无状态","slug":"实现无状态","link":"#实现无状态","children":[{"level":3,"title":"JWT","slug":"jwt","link":"#jwt","children":[]},{"level":3,"title":"RSA","slug":"rsa","link":"#rsa","children":[]},{"level":3,"title":"结合RSA的鉴权","slug":"结合rsa的鉴权","link":"#结合rsa的鉴权","children":[]},{"level":3,"title":"Java实现","slug":"java实现","link":"#java实现","children":[]}]}],"git":{"createdTime":1667915485000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"1425795337@qq.com","commits":1,"url":"https://github.com/logycoconut"},{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":4,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":2.78,"words":835},"filePathRelative":"archive/blog/2020/200221_如何实现无状态登录.md","localizedDate":"2020年2月21日","autoDesc":true}`);export{r as comp,d as data};
