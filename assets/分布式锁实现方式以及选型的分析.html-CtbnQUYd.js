import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as l,o as i}from"./app-CAtmO8tN.js";const r={};function a(n,e){return i(),o("div",null,[...e[0]||(e[0]=[l('<h2 id="简单说一下锁" tabindex="-1"><a class="header-anchor" href="#简单说一下锁"><span>简单说一下锁</span></a></h2><h3 id="锁的几个基本条件" tabindex="-1"><a class="header-anchor" href="#锁的几个基本条件"><span>锁的几个基本条件</span></a></h3><ul><li>锁必须是<strong>互斥</strong>的，即在任何时候只能有一个线程持有锁</li><li>锁必须是<strong>可重入</strong>的，即如果一个线程已经持有了锁，那么它可以多次获取锁儿不会发生死锁</li><li>锁必须是<strong>安全</strong>的，即如果一个线程获得了锁，那么即使崩溃或失去连接，锁也必须释放</li></ul><h3 id="分布式锁的几个条件" tabindex="-1"><a class="header-anchor" href="#分布式锁的几个条件"><span>分布式锁的几个条件</span></a></h3><ul><li><strong>高性能</strong>：分布式锁可能会有很多服务器来获取，所以一定要保证锁能够高效地获取和释放，不然锁又会成为一个瓶颈</li><li><strong>高可用</strong>：不能因为某一个分布式锁获取的服务不可用，导致所有服务都拿不到或者释放锁</li><li><strong>锁失效机制</strong>：假设某个应用获取到锁之后，一直没有释放锁，可能服务本身已经挂掉了。不能一直不释放，导致其他服务一直获取不到锁</li><li><strong>非阻塞特性</strong>：在某个服务来获取锁时，假设该锁已经被另一个服务获取，要能直接返回失败，不能一直等待</li></ul><h2 id="常见的分布式锁实现方式-如何进行选型" tabindex="-1"><a class="header-anchor" href="#常见的分布式锁实现方式-如何进行选型"><span>常见的分布式锁实现方式，如何进行选型</span></a></h2><p>常见的分布式锁实现方式包括基于数据库、基于缓存、基于 ZooKeeper 等方式</p><h3 id="基于-mysql-实现分布式锁" tabindex="-1"><a class="header-anchor" href="#基于-mysql-实现分布式锁"><span>基于 MySQL 实现分布式锁</span></a></h3><blockquote><p>通过数据库的事务特性来保证锁的正确性，将锁状态存储在服务器中</p></blockquote><ul><li><p>通过使用数据库的行级锁来保证对统一资源的访问互斥<br> 例如使用 MySQL 的 <code>select ... for update</code> 或者 <code>update ... where</code> 来实现分布式锁</p></li><li><p>通过使用数据库的唯一索引来实现分布式锁<br> 例如在 MySQL 中可以使用 <code>insert ... on duplicate key update</code> 来实现<br> 在此方式下，需要将资源的唯一标识作为唯一索引，每次需要获取锁时，尝试向数据库中插入一条记录，如果已存在，则更新记录，否则插入一条新纪录，插入成功即可获得锁</p></li></ul><p><strong>优缺点分析</strong></p><ul><li><strong>优点</strong><ul><li>实现简单：相对于基于 ZooKeeper 的实现方式，基于 MySQL 的实现方式较为简单，只需要使用 MySQL 的事务和唯一索引即可实现分布式锁</li><li>不需要引入额外的依赖：MySQL 较 ZooKeeper 来说常用，对于没有 ZooKeeper 的系统来说，可以方便地使用基于 MySQL 的分布式锁</li></ul></li><li><strong>缺点</strong><ul><li>对 MySQL 的可用性和性能要求比较高：需要保证 MySQL 集群的可用性和性能，否则将会影响到整个系统的正常运行</li><li>不适合高频率的加锁和解锁操作：基于 MySQL 的实现方式使用数据库的事务机制实现锁的管理，因此在高频率的加锁和解锁操作场景下，会产生大量的数据库连接和事务操作，导致性能瓶颈</li><li>不适合长时间占用锁资源：由于 MySQL 的锁实现方式是使用行锁或表锁，因此不适合长时间占用锁资源，否则会导致锁冲突，进而影响到整个系统的性能和可用行</li></ul></li></ul><h3 id="基于-redis-的分布式锁实现方式" tabindex="-1"><a class="header-anchor" href="#基于-redis-的分布式锁实现方式"><span>基于 Redis 的分布式锁实现方式</span></a></h3><blockquote><p>基于缓存的分布式锁实现方式，通常使用分布式缓存存储锁状态，例如使用 Redis 的 SETNX 操作</p></blockquote><ul><li>使用 Redis 的 SETNX 命令获取锁，SETNX 命令可以在指定的键不存在时设置该键的值，如果键已经存在则不做任何操作</li><li>可以使用 Redis 的带有过期时间的 SETEX 或者类似的命令，保证锁的自动过期，避免死锁</li></ul><p><strong>优缺点分析</strong></p><ul><li><strong>优点</strong><ul><li>实现简单：基于缓存的分布式锁的实现方式比较简单，只需要使用缓存的 CAS 原语和过期时间即可实现</li><li>支持高并发：缓存系统一般都支持高并发的读写操作，因此可以较好地支持高并发下的分布式锁场景</li><li>可以较好地解决死锁问题：过期时间机制可以较好地避免死锁问题，一旦某个节点因为故障导致锁没有被释放，那么在过期时间到达之后，该节点的锁会自动失效，从而不会影响整个系统的运行</li></ul></li><li>缺点 <ul><li>依赖于缓存系统的可用性和性能：如果缓存系统不稳定或者出现性能瓶颈，将会影响到整个系统的正常运行</li><li>可靠性较低：缓存系统本身就是一个内存存储系统，因此在发生故障时，缓存中的数据可能会丢失，因此需要设计合理的故障恢复机制</li></ul></li></ul><h3 id="基于-zookeeper-的分布式锁实现方式" tabindex="-1"><a class="header-anchor" href="#基于-zookeeper-的分布式锁实现方式"><span>基于 ZooKeeper 的分布式锁实现方式</span></a></h3><blockquote><p>通常使用 ZooKeeper 的节点特性来实现，例如使用 ZooKeeper 的临时节点来实现</p></blockquote><ul><li>在 ZooKeeper 上创建临时节点，每个节点对应一把锁，锁的持有者在创建节点时添加自己的标识。当锁的持有者释放锁时，删除对应的节点即可</li><li>利用 ZooKeeper 提供的 watch 机制，当节点被删除时，可以通过 watch 机制进行通知，从而实现锁的等待机制</li></ul><p><strong>优缺点分析</strong></p><ul><li>优点 <ul><li>实现简单：ZooKeeper 已经实现了分布式协调服务的机制，提供了临时节点、watch 机制等原语，可以方便地实现分布式锁</li><li>具有一定的容错能力：ZooKeeper 是一个高可用的分布式协调服务，能够保证分布式锁在出现故障时的可用性</li><li>对于分布式环境下的锁管理效果良好</li></ul></li><li>缺点 <ul><li>对 ZooKeeper 的可用性和性能要求较高</li><li>依赖性较强</li></ul></li></ul>',22)])])}const c=t(r,[["render",a]]),d=JSON.parse(`{"path":"/resource/staged/SeniorDevelopment/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%80%89%E5%9E%8B%E7%9A%84%E5%88%86%E6%9E%90.html","title":"to be perfected","lang":"zh-CN","frontmatter":{"title":"to be perfected","index":false,"date":"2023-03-11T00:00:00.000Z","tag":["Redis"],"description":"简单说一下锁 锁的几个基本条件 锁必须是互斥的，即在任何时候只能有一个线程持有锁 锁必须是可重入的，即如果一个线程已经持有了锁，那么它可以多次获取锁儿不会发生死锁 锁必须是安全的，即如果一个线程获得了锁，那么即使崩溃或失去连接，锁也必须释放 分布式锁的几个条件 高性能：分布式锁可能会有很多服务器来获取，所以一定要保证锁能够高效地获取和释放，不然锁又会成...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"to be perfected\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-11T14:19:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"logycoconut\\",\\"url\\":\\"https://logycoconut.github.io/\\"}]}"],["meta",{"property":"og:url","content":"https://logycoconut.github.io/resource/staged/SeniorDevelopment/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%80%89%E5%9E%8B%E7%9A%84%E5%88%86%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"logycoconut's k-lab"}],["meta",{"property":"og:title","content":"to be perfected"}],["meta",{"property":"og:description","content":"简单说一下锁 锁的几个基本条件 锁必须是互斥的，即在任何时候只能有一个线程持有锁 锁必须是可重入的，即如果一个线程已经持有了锁，那么它可以多次获取锁儿不会发生死锁 锁必须是安全的，即如果一个线程获得了锁，那么即使崩溃或失去连接，锁也必须释放 分布式锁的几个条件 高性能：分布式锁可能会有很多服务器来获取，所以一定要保证锁能够高效地获取和释放，不然锁又会成..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:19:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2023-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:19:39.000Z"}]]},"git":{"createdTime":1678587865000,"updatedTime":1739283579000,"contributors":[{"name":"logycoconut","username":"logycoconut","email":"logycoconut@foxmail.com","commits":7,"url":"https://github.com/logycoconut"}]},"readingTime":{"minutes":4.98,"words":1495},"filePathRelative":"resource/staged/SeniorDevelopment/Redis/分布式锁实现方式以及选型的分析.md","autoDesc":true}`);export{c as comp,d as data};
